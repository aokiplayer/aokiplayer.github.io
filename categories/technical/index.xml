<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technical on Yagamo Style</title>
    <link>https://yagamo-style.com/categories/technical/</link>
    <description>Recent content in Technical on Yagamo Style</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Mon, 02 Mar 2020 18:03:25 +0900</lastBuildDate><atom:link href="https://yagamo-style.com/categories/technical/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>iOS/iPadOS 13 のモーダル画面から戻った際に、ライフサイクルメソッドが呼ばれないパターンがある</title>
      <link>https://yagamo-style.com/2020/default-modal-segue-xcode11/</link>
      <pubDate>Mon, 02 Mar 2020 18:03:25 +0900</pubDate>
      
      <guid>https://yagamo-style.com/2020/default-modal-segue-xcode11/</guid>
      <description>はじめに  iOS/iPadOS 13 から、モーダルで画面遷移した際はデフォルトでは全画面ではなく少し小さい表示になります その画面から戻る際、これまでは unwind セグエを呼ぶか dismiss する必要がありましたが、モーダルの画面をスワイプダウンすることで遷移が可能となりました その場合、本来呼ばれるはずのライフサイクルメソッドが呼ばれません  もちろん、 unwind セグエメソッドも呼ばれません unwind セグエから戻っても、ライフサイクルメソッドは呼ばれません（unwind セグエメソッドは呼ばれる）    サンプル 画面レイアウト New Default シーンへのセグエ  Xcode 11 でのデフォルト設定 Presentation が Same as Destination  Full Screen シーンへのセグエ  Presentation を Full Screen に変更 デフォルトと異なり、画面全体を覆う（iOS 12 までの Modal）  ソースコード ViewController（最初の画面） import UIKit  class ViewController: UIViewController {   override func viewDidLoad() {  super.viewDidLoad()  print(#function)  }   override func viewWillDisappear(_ animated: Bool) {  super.</description>
    </item>
    
    <item>
      <title>UIViewControllerのライフサイクルメソッド</title>
      <link>https://yagamo-style.com/2019/viewcontrollerlifecycle/</link>
      <pubDate>Tue, 21 May 2019 12:19:51 +0900</pubDate>
      
      <guid>https://yagamo-style.com/2019/viewcontrollerlifecycle/</guid>
      <description>はじめに  iOSアプリを作成していて、どのタイミングでどのメソッドが呼ばれるんだっけ？となることは多いです 特に、画面遷移の際に困ることがあります なので、非常に単純なサンプルを作成しておきました  各メソッド内で、コンソール出力をしているのみです    検証環境  Xcode 10.2 iOS 12.2 Swift 5  サンプルプロジェクト  aokiplayer/ViewControllerLifeCycleSample  サンプルの画面構成   画面はストーリーボードで作成しています
  A, Bの2画面があり、以下のように遷移します（Aが初期画面）
 A -&amp;gt; Bは、単純にPresent Modallyなセグエで遷移 B -&amp;gt; Aは、unwindセグエで遷移    コンソール出力例 アプリ起動（Aを表示）  レイアウト系が2度呼ばれています  レイアウトは、様々なタイミングで呼ばれるのでこのように複数回呼ばれる可能性があるためです  boundsが変更されたり、サブビューが追加されたりしても呼ばれます   Auto Layoutの制約を明示的に設定せず、Autoresizing maskをAuto Layoutに変換した場合などは1度しか呼ばれなかったりします    A: init(coder:) A: loadView() A: viewDidLoad() A: viewWillAppear(_:) A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() A: viewDidAppear(_:) 画面を回転（A画面表示中）  レイアウトを組み直す必要が発生するので、こんな感じですね  A: viewWillTransition(to:with:) A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() HOMEボタンを押す（A画面表示中）  画面は表示されなくなりますが、実際にはいずれのコールバックも呼ばれていません  このあたりの挙動は、Androidとは異なりますね（Androidではこのタイミングでもコールバック呼ばれる）    HOME画面でアイコンをタップ（上記の操作後）  非表示状態からの復帰ですが、いずれのコールバックも呼ばれていません  これも、Androidの場合はコールバックが呼ばれますね    Bへ遷移（Present Modallyセグエ）  ポイントはAのprepare(for:sender:)のタイミングです  ここで必要なデータの受け渡しを行いますが、BのviewDidLoad()よりも前です そのため、この時点ではBの持っているビューはnilであり、データを渡そうとすると実行時エラーとなります     B: init(coder:) A: prepare(for:sender:)  B: loadView()  B: viewDidLoad() A: viewWillDisappear(_:)  B: viewWillAppear(_:)  B: viewWillLayoutSubviews()  B: viewDidLayoutSubviews() A: viewWillLayoutSubviews() A: viewDidLayoutSubviews()  B: viewWillLayoutSubviews()  B: viewDidLayoutSubviews()  B: viewDidAppear(_:) A: viewDidDisappear(_:) Aへ戻る（unwindセグエ）  unwindセグエで戻る際も、prepare(for:sender:)は呼ばれています   B: prepare(for:sender:) A: unwindToFirst(_:)  B: viewWillDisappear(_:) A: viewWillAppear(_:) A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() A: viewDidAppear(_:)  B: viewDidDisappear(_:)  B: deinit A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() まとめ  初心者の陥りやすい点としては、prepare(for:sender:)内でのデータの受け渡しです 「遷移先画面のビューはまだnil」という点は、しっかり認識しておきましょう  </description>
    </item>
    
    <item>
      <title>iOSにおけるPush通知の基本1（通知の受信まで）</title>
      <link>https://yagamo-style.com/2019/remotenotification01/</link>
      <pubDate>Thu, 18 Apr 2019 09:30:15 +0900</pubDate>
      
      <guid>https://yagamo-style.com/2019/remotenotification01/</guid>
      <description>はじめに  Push通知は、使い方によっては非常に効果的です  通知しすぎると、邪魔になってしまいますが   ここでは、Push通知の基本的な実装方法を説明します Push通知の実装には、UserNotificationsフレームワークを利用します  ローカル通知にも、同じフレームワークを利用します 昔と違って、ひとつのフレームワークで両方に対応できていいですね    検証環境  Xcode 10.2 iOS 12.2 Swift 5 iPod touch 6th generation  必要なもの  Apple Developer Programのアカウント  Apple Developerサイト上で、以下の確認・作成が必要なため  Team ID Authentication Key     APNs（Apple Push Notification Service）に対応した、Push通知を送信するサーバ  FirebaseとかMicrosoft Azureとか、いろいろなサービスが対応してます テストするだけなら、APNsに対応したいろいろなツールがあります  Dwarven/PushMeBaby onmyway133/PushNotifications   APNsは、その名のとおりAppleのPush通知サービスです  Push通知の送信は、必ずこのサービスを経由します     iPhoneやiPadなどの実デバイス   シミュレータではPush通知が利用できないため
  シミュレータでPush通知の登録をしようとすると、コンソールに以下のようなメッセージが出力されます</description>
    </item>
    
  </channel>
</rss>
