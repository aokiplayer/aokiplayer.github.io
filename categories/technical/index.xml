<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technical :: カテゴリー :: Yagamo Style</title>
    <link>https://yagamo-style.com/categories/technical/index.html</link>
    <description></description>
    <generator>Hugo</generator>
    <language>ja-JP</language>
    <lastBuildDate>Mon, 02 Mar 2020 18:03:25 +0900</lastBuildDate>
    <atom:link href="https://yagamo-style.com/categories/technical/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>iOS/iPadOS 13 のモーダル画面から戻った際に、ライフサイクルメソッドが呼ばれないパターンがある</title>
      <link>https://yagamo-style.com/2020/03/02/default-modal-segue-xcode11/index.html</link>
      <pubDate>Mon, 02 Mar 2020 18:03:25 +0900</pubDate>
      <guid>https://yagamo-style.com/2020/03/02/default-modal-segue-xcode11/index.html</guid>
      <description>はじめに iOS/iPadOS 13 から、モーダルで画面遷移した際はデフォルトでは全画面ではなく少し小さい表示になります その画面から戻る際、これまでは unwind セグエを呼ぶか dismiss する必要がありましたが、モーダルの画面をスワイプダウンすることで遷移が可能となりました その場合、本来呼ばれるはずのライフサイクルメソッドが呼ばれません もちろん、 unwind セグエメソッドも呼ばれません unwind セグエから戻っても、ライフサイクルメソッドは呼ばれません（unwind セグエメソッドは呼ばれる） サンプル 画面レイアウト New Default シーンへのセグエ Xcode 11 でのデフォルト設定 Presentation が Same as Destination Full Screen シーンへのセグエ Presentation を Full Screen に変更 デフォルトと異なり、画面全体を覆う（iOS 12 までの Modal） ソースコード ViewController（最初の画面） import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() print(#function) } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) print(#function) } override func viewDidDisappear(_ animated: Bool) { super.viewDidDisappear(animated) print(#function) } override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) print(#function) } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) print(#function) } @IBAction func unwindToMain(_ unwindSegue: UIStoryboardSegue) { print(&#34;Returned through unwind segue.&#34;) } override func prepare(for segue: UIStoryboardSegue, sender: Any?) { let style: String switch segue.destination.modalPresentationStyle { case .automatic: style = &#34;automatic&#34; case .currentContext: style = &#34;currentContext&#34; case .custom: style = &#34;custom&#34; case .formSheet: style = &#34;formSheet&#34; case .fullScreen: style = &#34;fullScreen&#34; case .none: style = &#34;none&#34; case .overCurrentContext: style = &#34;overCurrentContext&#34; case .overFullScreen: style = &#34;overFullScreen&#34; case .pageSheet: style = &#34;pageSheet&#34; case .popover: style = &#34;popOver&#34; @unknown default: fatalError(&#34;Maybe there will be new case.&#34;) } print(style) } } NewDefaultVC（NewDefault ボタンから遷移する画面） import UIKit class NewDefaultVC: UIViewController { override func viewDidLoad() { super.viewDidLoad() } override func prepare(for segue: UIStoryboardSegue, sender: Any?) { print(#file.components(separatedBy: &#34;/&#34;).last!) } } FullScreenVC（FullScreen ボタンから遷移する画面） import UIKit class FullScreenVC: UIViewController { override func viewDidLoad() { super.viewDidLoad() } override func prepare(for segue: UIStoryboardSegue, sender: Any?) { print(#file.components(separatedBy: &#34;/&#34;).last!) } } 実行結果 New Default ボタンで遷移 -&gt; Unwind ボタンで戻る pageSheet NewDefaultVC.swift Returned through unwind segue. unwind セグエメソッドは呼ばれていますが、戻ったシーンのライフサイクルメソッドが呼ばれていません New Default ボタンで遷移 -&gt; 画面上部からスワイプダウンで戻る pageSheet やはり、戻ったシーンのライフサイクルメソッドは呼ばれていません また、 unwind セグエを利用していないので、当然ですが unwind セグエメソッドも呼ばれていませんね 同様に、 New Default シーンの prepare(for:sender:) も呼ばれていません Full Screen ボタンで遷移 -&gt; Unwind ボタンで戻る fullScreen viewWillDisappear(_:) viewDidDisappear(_:) FullScreenVC.swift Returned through unwind segue. viewWillAppear(_:) viewDidAppear(_:) こちらは、 iOS 12 までと同じですね 戻ったシーンのライフサイクルメソッドおよび unwind セグエメソッドの、どちらも呼ばれています まとめ iOS 13 から新しくなったデフォルトのモーダルの挙動は、ユーザにとっては「メインとは別の流れにいる」のを認識しやすいと思います また、スワイプダウンで戻れるので、操作としても直感的です ただ、「戻った際に何か処理をさせる」必要がある場合は要注意ですね 今回のサンプルは、aokiplayer/ModalXcode11 に置きました</description>
    </item>
    <item>
      <title>UIViewControllerのライフサイクルメソッド</title>
      <link>https://yagamo-style.com/2019/05/21/viewcontrollerlifecycle/index.html</link>
      <pubDate>Tue, 21 May 2019 12:19:51 +0900</pubDate>
      <guid>https://yagamo-style.com/2019/05/21/viewcontrollerlifecycle/index.html</guid>
      <description>はじめに iOSアプリを作成していて、どのタイミングでどのメソッドが呼ばれるんだっけ？となることは多いです 特に、画面遷移の際に困ることがあります なので、非常に単純なサンプルを作成しておきました 各メソッド内で、コンソール出力をしているのみです 検証環境 Xcode 10.2 iOS 12.2 Swift 5 サンプルプロジェクト aokiplayer/ViewControllerLifeCycleSample サンプルの画面構成 画面はストーリーボードで作成しています&#xA;A, Bの2画面があり、以下のように遷移します（Aが初期画面）&#xA;A -&gt; Bは、単純にPresent Modallyなセグエで遷移 B -&gt; Aは、unwindセグエで遷移 コンソール出力例 アプリ起動（Aを表示） レイアウト系が2度呼ばれています レイアウトは、様々なタイミングで呼ばれるのでこのように複数回呼ばれる可能性があるためです boundsが変更されたり、サブビューが追加されたりしても呼ばれます Auto Layoutの制約を明示的に設定せず、Autoresizing maskをAuto Layoutに変換した場合などは1度しか呼ばれなかったりします A: init(coder:) A: loadView() A: viewDidLoad() A: viewWillAppear(_:) A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() A: viewDidAppear(_:) 画面を回転（A画面表示中） レイアウトを組み直す必要が発生するので、こんな感じですね A: viewWillTransition(to:with:) A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() HOMEボタンを押す（A画面表示中） 画面は表示されなくなりますが、実際にはいずれのコールバックも呼ばれていません このあたりの挙動は、Androidとは異なりますね（Androidではこのタイミングでもコールバック呼ばれる） HOME画面でアイコンをタップ（上記の操作後） 非表示状態からの復帰ですが、いずれのコールバックも呼ばれていません これも、Androidの場合はコールバックが呼ばれますね Bへ遷移（Present Modallyセグエ） ポイントはAのprepare(for:sender:)のタイミングです ここで必要なデータの受け渡しを行いますが、BのviewDidLoad()よりも前です そのため、この時点ではBの持っているビューはnilであり、データを渡そうとすると実行時エラーとなります B: init(coder:) A: prepare(for:sender:) B: loadView() B: viewDidLoad() A: viewWillDisappear(_:) B: viewWillAppear(_:) B: viewWillLayoutSubviews() B: viewDidLayoutSubviews() A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() B: viewWillLayoutSubviews() B: viewDidLayoutSubviews() B: viewDidAppear(_:) A: viewDidDisappear(_:) Aへ戻る（unwindセグエ） unwindセグエで戻る際も、prepare(for:sender:)は呼ばれています B: prepare(for:sender:) A: unwindToFirst(_:) B: viewWillDisappear(_:) A: viewWillAppear(_:) A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() A: viewDidAppear(_:) B: viewDidDisappear(_:) B: deinit A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() まとめ 初心者の陥りやすい点としては、prepare(for:sender:)内でのデータの受け渡しです 「遷移先画面のビューはまだnil」という点は、しっかり認識しておきましょう</description>
    </item>
    <item>
      <title>iOSにおけるPush通知の基本1（通知の受信まで）</title>
      <link>https://yagamo-style.com/2019/04/18/remotenotification01/index.html</link>
      <pubDate>Thu, 18 Apr 2019 09:30:15 +0900</pubDate>
      <guid>https://yagamo-style.com/2019/04/18/remotenotification01/index.html</guid>
      <description>はじめに Push通知は、使い方によっては非常に効果的です 通知しすぎると、邪魔になってしまいますが ここでは、Push通知の基本的な実装方法を説明します Push通知の実装には、UserNotificationsフレームワークを利用します ローカル通知にも、同じフレームワークを利用します 昔と違って、ひとつのフレームワークで両方に対応できていいですね 検証環境 Xcode 10.2 iOS 12.2 Swift 5 iPod touch 6th generation 必要なもの Apple Developer Programのアカウント Apple Developerサイト上で、以下の確認・作成が必要なため Team ID Authentication Key APNs（Apple Push Notification Service）に対応した、Push通知を送信するサーバ FirebaseとかMicrosoft Azureとか、いろいろなサービスが対応してます テストするだけなら、APNsに対応したいろいろなツールがあります Dwarven/PushMeBaby onmyway133/PushNotifications APNsは、その名のとおりAppleのPush通知サービスです Push通知の送信は、必ずこのサービスを経由します iPhoneやiPadなどの実デバイス シミュレータではPush通知が利用できないため&#xA;シミュレータでPush通知の登録をしようとすると、コンソールに以下のようなメッセージが出力されます&#xA;Failed to register: Error Domain=NSCocoaErrorDomain Code=3010 &#34;remote notifications are not supported in the simulator&#34; UserInfo={NSLocalizedDescription=remote notifications are not supported in the simulator} 事前準備（Apple Developerサイト上） Team IDの確認 Apple Developerサイトにログイン</description>
    </item>
  </channel>
</rss>