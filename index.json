[
{
	"uri": "https://yagamo-style.com/",
	"title": "Yagamo Style",
	"tags": [],
	"description": "",
	"content": "Yagamo Style 技術メモとか、カンファレンスの感想とかを書いてます。\nAbout me\n"
},
{
	"uri": "https://yagamo-style.com/2018/",
	"title": "2018",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2019/",
	"title": "2019",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2020/",
	"title": "2020",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2021/",
	"title": "2021",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2022/",
	"title": "2022",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2023/",
	"title": "2023",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2024/",
	"title": "2024",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2024/swiftlint-plugins/",
	"title": "Build Tool プラグインとしての SwiftLint 導入時のエラー対処",
	"tags": ["iOS", "Swift", "SwiftLint", "Swift Package Manager"],
	"description": "",
	"content": " 2025.02.07 追記\nRun Script にペーストするスクリプトが公式サイトで変更されていたので修正\n はじめに Xcode 15.4 で、Build Tool プラグインとしての SwiftLint の実行に失敗する現象に遭遇しました。 基本的には SwiftLint パッケージをプロジェクトに導入 -\u0026gt; Build Phases の Run Build Tool Plug-ins に追加するだけで動作するはず（以前は動作していた）なのですが、Xcode のマイナーバージョンアップをしたところエラーが発生するようになりました。\n細かくは検証できていませんが、Xcode 15.1 から 15.4 の間のどこかからのようです。 また、SwiftLint 自体も、導入の際に指定する URL が変わっていたりするようです。\n執筆時点で最新の、Xcode 15.4 における回避方法を記載します。\n今回、iOS プロジェクトは Xcode のウィザードから作成したものを利用しています。 そのため、今回はマニフェストファイルを利用せず、Xcode からパッケージを追加します。\n検証環境  macOS Sonoma 14.5 (23F79) Xcode 15.4 (15F31d)  導入手順 SwiftPM を利用して SwiftLint への依存性を追加   Xcode メニュー -\u0026gt; Add Package Dependencies...\n  検索欄に https://github.com/SimplyDanny/SwiftLintPlugins を入力し、Add Package ボタンをクリック\n URL が SwiftLint 公式のものでない点に注意  以前の手順では、公式の https://github.com/realm/SwiftLint となっていた   Dependency Rule は Up to Next Major Version のままで OK    Build Phases から Run Script を追加   アプリターゲットを選択し、Build Phases タブを選択\n  + アイコンから New Run Script Phase を選択して Run Script を追加し、ドラッグして Compile Sources の後へ移動\n  以下の内容を Run Script で実行するスクリプトとして貼り付け\nSWIFT_PACKAGE_DIR=\u0026#34;${BUILD_DIR%Build/*}SourcePackages/artifacts\u0026#34; SWIFTLINT_CMD=$(ls \u0026#34;$SWIFT_PACKAGE_DIR\u0026#34;/swiftlintplugins/SwiftLintBinary/SwiftLintBinary.artifactbundle/swiftlint-*-macos/bin/swiftlint | head -n 1)  if test -f \u0026#34;$SWIFTLINT_CMD\u0026#34; 2\u0026gt;\u0026amp;1 then  \u0026#34;$SWIFTLINT_CMD\u0026#34; else  echo \u0026#34;warning: `swiftlint` command not found - See https://github.com/realm/SwiftLint#installation for installation instructions.\u0026#34; fi   本来は Build Phases の Run Build Tool Plug-ins に SwiftLintBuildToolPlugin を追加するだけで OK なはずですが、プロジェクトのディレクトリ構成など様々な理由により上手くいかないことがあるようです。 その回避策として、SwiftLint の公式サイトで上記の方法が示されていました。\n実行 command + B などでビルドを実行すると、SwiftLint が実行されます。 通常通り設定ファイル .swiftlint.yml をプロジェクトのルートディレクトリに配置して、チェックするルールをカスタマイズできます。ルールについて詳しくは、公式サイト内の Rules の項目をご覧ください。\nまとめ SwiftPM の Build Tool プラグインや、Xcode の Build Phases などに関してはまだ理解が浅い点が多いのですが、SwiftLint の公式サイトを見ても「Xcode 15 でパーミッションが変わった」とか「Apple Silicon だと Homebrew でインストールされるパスが変わった」とかいろいろ書かれています（後者は今回の件とは無関係ですが）。 まずは、公式の情報を見て環境を構築できるのが大切ですね。その上で、必要な部分を深掘りしていきたいと思います。\n参考 realm/SwiftLint: A tool to enforce Swift style and conventions.\n"
},
{
	"uri": "https://yagamo-style.com/tags/ios/",
	"title": "iOS",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/tags/swift/",
	"title": "Swift",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/tags/swift-package-manager/",
	"title": "Swift Package Manager",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/tags/swiftlint/",
	"title": "SwiftLint",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/tags/javascript/",
	"title": "JavaScript",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2024/js-logical-and/",
	"title": "JavaScript の &amp;&amp; 演算子は true/false を返すとは限らない",
	"tags": ["JavaScript"],
	"description": "",
	"content": "はじめに React Hook Form のサンプルを見ていたら、こんなコードがありました。\n というか、React 本家のチュートリアルにもありますね。 https://ja.react.dev/learn/conditional-rendering#logical-and-operator-\n {errors.exampleRequired \u0026amp;\u0026amp; \u0026lt;span\u0026gt;This field is required\u0026lt;/span\u0026gt;} 普段 JavaScript を書かない立場としては、すぐには理解できませんでした。 入力チェックの結果、エラーがある場合ならこういう挙動のはず。\n errors.exampleRequired に何らかのオブジェクトが入っている true と評価される 右オペランドが評価される  右オペランドが true と評価されれば、true が返される 右オペランドが false と評価されれば、false が返される    入力チェックの結果、エラーがない場合ならこうなるよね？\n errors.exampleRequired が undefined false と評価される 右オペランドを評価せず、false が返される  どちらにせよ、true/false のいずれかが返されるので \u0026lt;span\u0026gt;This field is required\u0026lt;/span\u0026gt; は出力されないように思えます。 正しく動作させるなら、普通に考えればこうなるかなと。\n{errors.exampleRequired ? \u0026lt;span\u0026gt;This field is required\u0026lt;/span\u0026gt; : \u0026#39;\u0026#39;} JavaScript の \u0026amp;\u0026amp; 演算子が Java などと比べて特殊なので、確認してみます。\n\u0026amp;\u0026amp; 演算子の基本 JavaScript も C 言語の流れを汲んでいる（基本的な文法の面では）ので、基本的には同じです。\n AND（論理積）を求める ショートカット演算子なので、左オペランドを評価して式全体の結果が確定すれば、右オペランドは評価しない  const t1 = true; const t2 = true; const f1 = false; const f2 = false; t1 \u0026amp;\u0026amp; t2 // true t1 \u0026amp;\u0026amp; f2 // false f1 \u0026amp;\u0026amp; t1 // false, f1 を評価した時点で全体の結果が確定するので t1 は評価されない ちょっと変わった使い方 MDN を見ると、以下のような説明があります。\n 一般的には、この演算子は左から右に向けて評価した際に最初の偽値のオペランドに遭遇したときにはその値を、またはすべてが真値であった場合は最後のオペランドの値を返します。\n つまり、論理演算子なので常に true/false の真偽値を返すと思いがちですが、実際には以下のような挙動となっています。\n 左オペランドが false として扱われる値の場合: 左オペランドを返す 左オペランドが true として扱われる値の場合: 右オペランドを返す  上記の挙動に当てはめた結果、真偽値型の場合は我々のよく知る挙動となっているわけですね。\nということで、真偽値型以外に適用するとこんなことが起こってしまうわけです。 直感に反しますよね。\nconst tanaka = \u0026#39;田中まさひろ\u0026#39;; const satoda = \u0026#39;里田まい\u0026#39;; tanaka \u0026amp;\u0026amp; satoda // \u0026#39;里田まい\u0026#39; では最初の例は？ {errors.exampleRequired \u0026amp;\u0026amp; \u0026lt;span\u0026gt;This field is required\u0026lt;/span\u0026gt;} 以下の挙動となります。\n入力チェックの結果、エラーがある場合  errors.exampleRequired に何らかのオブジェクトが入っている true と評価される 右オペランドが返されて、メッセージを出力  入力チェックの結果、エラーがない場合  errors.exampleRequired は undefined false と評価される 左オペランドが返されて、undefined なので React は何も出力しない  まとめ Java などの、型を厳密に扱う言語に慣れていると JavaScript の \u0026amp;\u0026amp; の挙動は不思議に思えますね。 ですが、ドキュメントをしっかり読めば説明はあるので、注意して少しずつ慣れていきましょう。\n参考  論理 AND 演算子 (\u0026amp;\u0026amp;): 条件付きレンダー – React 論理積 (\u0026amp;\u0026amp;) - JavaScript | MDN  "
},
{
	"uri": "https://yagamo-style.com/2023/12/05/dynamic-callable/",
	"title": "Swift の dynamicCallable を利用して「オブジェクト(引数)」の形でメソッドを呼び出す",
	"tags": ["iOS", "Swift", "SwiftUI"],
	"description": "",
	"content": "はじめに 以前の記事 SwiftUI の dismiss() って「関数()」じゃなくて「オブジェクト()」だよね？ で、callAsFunction メソッドについて説明しました。 簡単に説明すると、型に callAsFunction という名前のメソッドを定義すると、オブジェクト(引数)のような形でメソッドを呼び出せるようになる仕組みです。\nSwiftUI の DismissAction が、そのような形をとっていました。\n// ビューを閉じるための DismissAction を取得 @Environment(\\.dismiss) private var dismiss: DismissAction  ...  // ビューを閉じる dismiss() // \u0026lt;--- dismiss.callAsFunction() の省略形 似たような仕組みがもうひとつあるので、今回はそちらについて紹介します。\n検証環境  Xcode 15.0 Swift 5.9  dynamicCallable @dynamicCallable で修飾した型には、以下のいずれかのメソッドの実装が必須となります。 メソッドの定義漏れやスペルミスをコンパイル時に気づける点が、callAsFunction とは異なりますね。\n   メソッド 説明     dynamicallyCall(withArguments:) 引数は ExpressibleByArrayLiteral プロトコルに準拠した型（配列など）   dynamicallyCall(withKeywordArguments:) 引数に ExpressibleByDictionaryLiteral プロトコルに準拠した型（ディクショナリなど）    dynamicallyCall(withArguments:) メソッド dynamicallyCall(withArguments:) は、可変長の引数を受け取れます。 メソッドの定義時には引数に配列などを指定しますが、メソッド名を省略した呼び出しの際には個別の値（本来、配列の要素とすべき値）をカンマ区切りで複数指定できます。\ndynamicallyCall(withArguments:) の例 import Foundation // 足し算をするためだけの構造体 @dynamicCallable struct AddAction { // 引数はExpressibleByArrayLiteralに準拠した型とする public func dynamicallyCall(withArguments args: [Int]) -\u0026gt; Int { return args.reduce(0, +) } } let add = AddAction() // 以下は add.dynamicallyCall(withArguments: [10, 20, 30]) の省略形 // この際、引数の配列は展開した状態で渡せる let result1 = add(10, 20, 30) print(result1) // メソッド名を記載した際には、引数は配列として渡す必要がある let result2 = add.dynamicallyCall(withArguments: [10, 20, 30, 40]) print(result2) 実行結果\n60 100 dynamicallyCall(withKeywordArguments:) メソッド dynamicallyCall(withKeywordArguments:) は、ラベル付き引数を複数指定できます。 Swift では関数やメソッドの引数ラベルはその宣言時に決めておく必要がありますが、dynamicallyCall(withKeywordArguments:) では呼び出し時に任意のラベルを指定できます。\ndynamicallyCall(withKeywordArguments:) の例 import Foundation // 足し算をするためだけの構造体 @dynamicCallable struct AddAction { // 引数はExpressibleByDictionaryLiteralに準拠した型とする public func dynamicallyCall(withKeywordArguments args: [String: Int]) -\u0026gt; Int { var sum = 0 print(\u0026#34;[引数リスト]\u0026#34;) for (name, value) in args { print(\u0026#34; \\(name), \\(value)\u0026#34;) sum += value } return sum } } let add = AddAction() // メソッド名は省略でき、引数のラベルと個数は自由に設定できる let result1 = add(a: 10, b: 20, c: 30) print(\u0026#34;合計: \\(result1)\u0026#34;, terminator: \u0026#34;\\n\\n\u0026#34;) // メソッド名は省略でき、引数のラベルと個数は自由に設定できる let result2 = add(x: 5, y: 10) print(\u0026#34;合計: \\(result2)\u0026#34;, terminator: \u0026#34;\\n\\n\u0026#34;) // メソッド名を記載した際には、引数はディクショナリとして渡す必要がある // キーはStringなので、ダブルクォートで囲む let result3 = add.dynamicallyCall(withKeywordArguments: [\u0026#34;num1\u0026#34;: 20, \u0026#34;num2\u0026#34;: 40]) print(\u0026#34;合計: \\(result3)\u0026#34;, terminator: \u0026#34;\\n\\n\u0026#34;) 実行結果\n[引数リスト] c, 30 a, 10 b, 20 合計: 60 [引数リスト] y, 10 x, 5 合計: 15 [引数リスト] num2, 40 num1, 20 合計: 60 dynamicallyCall(withKeywordArguments:) の例 2 通常、Swift では同じ引数ラベルを複数指定できません。 しかし、dynamicallyCall(withKeywordArguments:) の引数を KeyValuePairs（ディクショナリ同様、ExpressibleByDictionaryLiteral プロトコルに準拠）とすることにより、同じ引数ラベルを複数指定することも可能となります。\n例として、同じ引数ラベルを複数指定し、ラベルごとの数値の合計を求める機能を作成してみます。\nimport Foundation // 足し算をするためだけの構造体 @dynamicCallable struct AddAction { // 引数はExpressibleByDictionaryLiteralに準拠した型とする // KeyValuePairs型なら、同じラベルの引数を複数指定できる（ディクショナリではキーを重複できない） public func dynamicallyCall(withKeywordArguments args: KeyValuePairs\u0026lt;String, Int\u0026gt;) -\u0026gt; [String: Int] { var sum = 0 let groupedSum = Dictionary(grouping: args, by: { $0.key }) .mapValues { values in values.compactMap { key, value in value } .reduce(0, +) } return groupedSum } } let add = AddAction() // メソッド名は省略でき、引数のラベルと個数は自由に設定できる // 今回は引数をKeyValuePairs型にしているので、キーの重複もOK let result1 = add(john: 3, mary: 5, mary: 2, john: 4, ben: 10, john: 8, ben: 9) print(\u0026#34;個人別の合計点数\u0026#34;) print(result1, terminator: \u0026#34;\\n\\n\u0026#34;) // メソッド名を記載した際には、引数はディクショナリとして渡す必要がある // キーはStringなので、ダブルクォートで囲む let result2 = add.dynamicallyCall(withKeywordArguments: [ \u0026#34;john\u0026#34;: 3, \u0026#34;mary\u0026#34;: 5, \u0026#34;mary\u0026#34;: 2, \u0026#34;john\u0026#34;: 4, \u0026#34;ben\u0026#34;: 10, \u0026#34;john\u0026#34;: 8, \u0026#34;ben\u0026#34;: 9 ]) print(\u0026#34;個人別の合計点数\u0026#34;) print(result2, terminator: \u0026#34;\\n\\n\u0026#34;) 実行結果\n個人別の合計点数 [\u0026#34;ben\u0026#34;: 19, \u0026#34;john\u0026#34;: 15, \u0026#34;mary\u0026#34;: 7] 個人別の合計点数 [\u0026#34;mary\u0026#34;: 7, \u0026#34;ben\u0026#34;: 19, \u0026#34;john\u0026#34;: 15] まとめ dynamicCallable を利用すると、引数がcallAsFunction メソッドよりも柔軟に指定できますね。 また、定義時にメソッド名にミスがあればコンパイルエラーとして気づける点もありがたいです。\nただし、受け入れる引数のラベルと個数を宣言時に固定できない点には注意が必要です。\n作成したサンプルは、GitHub: aokiplayer/swift-sandboxCallAsFunction.playground に置きました。\n参考  Methods with Special Names (The Swift Programming Language)  "
},
{
	"uri": "https://yagamo-style.com/tags/swiftui/",
	"title": "SwiftUI",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2023/12/04/call-as-function/",
	"title": "SwiftUI の dismiss() って「関数()」じゃなくて「オブジェクト()」だよね？",
	"tags": ["iOS", "Swift", "SwiftUI"],
	"description": "",
	"content": "はじめに SwiftUI で多用されている Property Wrappers ですが、基本的に「なんか難しいことをやってくれてる」感じになってます。頻繁に利用される @Environment も、「こう書けばこう動く」という感じで何となく使っている人が多いと思います。\nところで、Property Wrapper そのものの機能とは関係ないですが、以下のコードの @Environment の dismiss() の部分はよく考えると不思議な構文ではないでしょうか。\n// ビューを閉じるための DismissAction を取得 @Environment(\\.dismiss) private var dismiss: DismissAction  ...  // ビューを閉じる dismiss() // \u0026lt;--- オブジェクト() という構文？？？ dismiss は DismissAction 型のオブジェクトなので、本来なら以下の形式でないと辻褄が合いませんよね。\ndismiss.何かメソッド名() // \u0026lt;--- オブジェクト.メソッド名() という構文ならわかる 検証環境  Xcode 15.0 Swift 5.9  callAsFunction メソッド 実は、これは dismiss.何かメソッド名() の省略形です。 具体的には dismiss.callAsFunction() です。\ncallAsFunction の例 例として、単に「足し算をするためだけの構造体」を用意し、callAsFunction メソッドを実装して利用してみます。\nimport Foundation // 足し算をするためだけの構造体 struct AddAction { public func callAsFunction(_ number1: Int, with number2: Int) -\u0026gt; Int { return number1 + number2 } } let add = AddAction() // 以下は add.callAsFunction(10, with: 20) の省略形 let result1 = add(10, with: 20) print(result1) // もちろん、メソッド名を書いても動作する let result2 = add.callAsFunction(50, with: 100) print(result2) 上記のコードでは、add は AddAction 型のオブジェクトですが、add(10, with: 20) の形で実行できていることがわかります。\n冒頭で紹介した DismissAction にも callAsFunction メソッドが定義されているため、dismiss() と記述できます。\ncallAsFunction メソッドの仕様  クラス、構造体、列挙型に宣言する メソッド名は callAsFunction 引数の型と数、戻り値の型は自由 オブジェクト.callAsFunction(引数)の形式で利用  注意点 callAsFunction というメソッド名は何らかのプロトコルで規定されているわけではないため、定義時にスペルミスをしてもエラーにはならない点に注意が必要です。 呼び出し側のコードを書いている時に、オブジェクト(引数) で呼べないので気づくこととなるでしょう。\nまとめ callAsFunction を積極的に定義する機会は多くないと思います。 しかし、Swift（特に SwiftUI）では意外と使われていたりするので、仕組みは知っておくと良いでしょう。\n以前に書いた記事 SwiftUI でサイズクラスに対応する でも、軽く触れています。\n作成したサンプルは、GitHub: aokiplayer/swift-sandboxCallAsFunction.playground に置きました。\n参考  Methods with Special Names (The Swift Programming Language) callAsFunction() | DismissAction (Apple Developer Documentation)  "
},
{
	"uri": "https://yagamo-style.com/2022/12/12/sizeclass-swiftui/",
	"title": "SwiftUI でサイズクラスに対応する",
	"tags": ["iOS", "Swift", "SwiftUI"],
	"description": "",
	"content": "はじめに Storyboard を利用していると、サイズクラスを利用して以下のように柔軟にビューのレイアウトを変更することが、比較的簡単に実現できていました。\n iPad で画面を分割していないので、幅が十分にあるからビューを横に並べよう iPad をマルチタスキングで画面分割して幅が狭くなったので、ビューを縦に並べよう  UIStackView で、幅と高さが Regular のデバイス（iPad で画面非分割時など）の場合のみサブビューを横に並べるのであれば、以下のような設定を行いました。\nサイズクラスは SwiftUI でも利用できるので、その使い方を記載します。\n今回のゴール 以下のように、画面幅の広い状態ではビューを横に、狭い状態では縦に並べるように設定します。\n   w:Regular w:Compact          検証環境  macOS Ventura 13.0.1 Xcode 14.1 iOS/iPadOS 16.1  サイズクラスとは サイズクラスは、その名のとおり「デバイスのサイズを分類する」概念です。サイズクラスでは、ざっくりとデバイスの縦横を「普通（Regular）」「小さい（Compact）」の組み合わせで表します。 それにより、最大で 4 通りの画面サイズ（w: Regular x h: Regular, \u0026hellip;, w: Compact x h: Compact）にデバイスを分類してビューのレイアウトを行います。 サイズクラスを使うことで、全部のデバイスに個々に対応せず、大まかな分類ごとにレイアウトを行えば済むので労力が削減できます。\n4 パターン全部に対応せずとも、iPad の画面分割のことを考えるのであれば、幅のみに着目して 2 パターンでレイアウトすることが多いのではないでしょうか。\nサイズクラス情報の取得 現在表示中のビューがどのサイズクラスなのかは、Environment から列挙型 UserInterfaceSizeClass 型の値として取得できます。\n@Environment(\\.horizontalSizeClass) private var horizontalSizeClass @Environment(\\.verticalSizeClass) private var verticalSizeClass この UserInterfaceSizeClass は定数として compact と regular の 2 つのケースを取るため、これを利用して条件分岐すれば、サイズクラスごとにレイアウトを変更できます。\n実装例（第 1 段階） では、サイズクラスごとにレイアウトを変えてみます。\nstruct Example1: View { // 水平方向のサイズクラス（compact, regular のいずれか） @Environment(\\.horizontalSizeClass) private var horizontalSizeClass @Environment(\\.verticalSizeClass) private var verticalSizeClass // 今回は使ってない var body: some View { // compact なら VStack, regular なら HStack でレイアウト if horizontalSizeClass == .compact { VStack { Text(\u0026#34;A\u0026#34;) .frame(maxWidth: .infinity, maxHeight: .infinity) .background(.green) .foregroundColor(.white) Text(\u0026#34;B\u0026#34;) .frame(maxWidth: .infinity, maxHeight: .infinity) .background(.orange) .foregroundColor(.white) } .font(.largeTitle) .frame(maxWidth: .infinity) .padding() } else { HStack { Text(\u0026#34;A\u0026#34;) .frame(maxWidth: .infinity, maxHeight: .infinity) .background(.green) .foregroundColor(.white) Text(\u0026#34;B\u0026#34;) .frame(maxWidth: .infinity, maxHeight: .infinity) .background(.orange) .foregroundColor(.white) } .font(.largeTitle) .frame(maxWidth: .infinity) .padding() } } } この実装で、w: Compact であれば VStack を利用してビューが縦に、w: Regular であれば HStack を利用して横に配置されます。\nただし、外側のビューが VStack か HStack かの違いだけですので、このままでは冗長です。 共通部分をビューとして切り出しても良いですが、大袈裟な気がします。\n実装例（第 2 段階） VStackLayout や HStackLayout などを利用することで、上記のコードをシンプルに記述できるようになります。\nstruct Example2: View { // 水平方向のサイズクラス（compact, regular のいずれか） @Environment(\\.horizontalSizeClass) private var horizontalSizeClass @Environment(\\.verticalSizeClass) private var verticalSizeClass // 今回は使ってない var body: some View { // compact なら VStackLayout, regular なら HStackLayout を生成 // VStackLayout, HStackLayout は Layout プロトコルに準拠しているので、AnyLayout に包める let layout = horizontalSizeClass == .compact ? AnyLayout(VStackLayout()) // \u0026lt;---- ① : AnyLayout(HStackLayout()) // \u0026lt;---- ① // 上で選択したレイアウトを利用してビューを配置 // この形で記述できているのは、callAsFunction(_:) が呼ばれているため layout { // \u0026lt;---- ② Text(\u0026#34;A\u0026#34;) .frame(maxWidth: .infinity, maxHeight: .infinity) .background(.green) .foregroundColor(.white) Text(\u0026#34;B\u0026#34;) .frame(maxWidth: .infinity, maxHeight: .infinity) .background(.orange) .foregroundColor(.white) } .font(.largeTitle) .frame(maxWidth: .infinity) .padding() } } ここでのポイントは以下です。\n ①: サイズクラスの値によって VStackLayout と HStackLayout を選択（AnyLayout に包む） ②: ① の AnyLayout を使ってレイアウト  ポイント① VStackLayout, HStackLayout, AnyLayout // compact なら VStackLayout, regular なら HStackLayout を生成 // VStackLayout, HStackLayout は Layout プロトコルに準拠しているので、AnyLayout に包める let layout = horizontalSizeClass == .compact ? AnyLayout(VStackLayout()) // \u0026lt;---- ① : AnyLayout(HStackLayout()) // \u0026lt;---- ① VStack や HStack は、内包するビューをイニシャライザに渡す必要があるため、引数なしではインスタンス化できません。\nそのような場合には VStackLayout や HStackLayout などが利用できます。 今回は定数 layout には VStackLayout と HStackLayout のどちらの値も取りうるので、両方を表現できるように AnyLayout に包んでいます。\nAnyLayout のイニシャライザに渡せるのは Layout プロトコル型ですが、VStackLayout や HStackLayout はこのプロトコルに準拠しています。\nこれで、どちらの場合であっても AnyLayout 型として扱うことができます。\nポイント② callAsFunction(_:) // 上で選択したレイアウトを利用してビューを配置 // この形で記述できているのは、callAsFunction(_:) が呼ばれているため layout { // \u0026lt;---- ②  Text(\u0026#34;A\u0026#34;)  .frame(maxWidth: .infinity, maxHeight: .infinity)  .background(.green)  .foregroundColor(.white)   Text(\u0026#34;B\u0026#34;)  .frame(maxWidth: .infinity, maxHeight: .infinity)  .background(.orange)  .foregroundColor(.white) } layout { ... } という記述には、少し違和感があるかもしれません。 これは  layout.callAsFunction( { ... } ) の省略形です。\nこの記述は callAsFunction(_:) という名前のメソッドを定義しておくと、メソッド名を省略して インスタンス() の形で呼び出すことができるようになっている言語仕様によるものです。AnyLayout や VStackLayout, HStackLayout が準拠している Layout プロトコルには、callAsFunction(_:) が宣言されています。\nもちろん、末尾クロージャなので引数リストの () も省略しています。\nまとめ サイズクラスに対応するだけなら、Environment から値を取得して条件分岐できるので単純です。 さらに、AnyLayout, VStackLayout, HStackLayout や callAsFunction(_:) などを利用することで簡潔なコードとすることができることがわかりましたね。\n参考  VStackLayout | Apple Developer Documentation HStackLayout | Apple Developer Documentation AnyLayout | Apple Developer Documentation callAsFunction(_:) | Apple Developer Documentation Methods with Special Names | Declarations — The Swift Programming Language (Swift 5.7)  上記の日本語版    "
},
{
	"uri": "https://yagamo-style.com/2022/10/26/type-erasure/",
	"title": "Swift の型消去（Type Erasure）",
	"tags": ["iOS", "Swift", "SwiftUI"],
	"description": "",
	"content": "はじめに SwiftUI をしっかり理解しようとすると、これまで意識しなくて良かった多くの言語機能を知る必要があり、なかなか苦労します。 その 1 つとして、型消去（Type Erasure）があります。 ずっとわかったようなわからないような感じだったので、腰を据えて調べてみました。 まだこれについては自信がないので、ご指摘などあれば GitHub から頂けるとうれしいです。\nサンプルは GitHub に置きました。\n前提: プロトコルに関する制約事項 Swift では、associatedtype を持つプロトコルは、型宣言に利用できません。 以下のコードでは、最下部で Store 型の変数を宣言しようとしていますが、コンパイルが通りません。 これは、Store の持つ associatedtype の型が確定しないためです。\n// お店で扱う商品の種類 struct Drug {  var item: String }  /** 何らかのお店を表すプロトコル. 商品の種類は associatedtype により柔軟に指定できるようにしている. */ protocol Store {  associatedtype T   var kind: T { get }  func kindsOfStore() -\u0026gt; T }  /** 具体的なお店（マツモトキヨシ）. associatedtype は Drug として確定. */ class MatsumotoKiyoshi: Store {  var kind: Drug   init(kind: Drug) {  self.kind = kind  }   func kindsOfStore() -\u0026gt; Drug {  return kind  } }  /** 具体的なお店（赤ひげ） associatedtype は Drug として確定. */ class AkaHige: Store {  var kind: Drug   init(kind: Drug) {  self.kind = kind  }   func kindsOfStore() -\u0026gt; Drug {  return kind  } }  /** MatsumotoKiyoshi は Store プロトコルに準拠しているので問題なさそうだが、 associatedtype を持つのでこの宣言はできない. */ var myStore1: Store = MatsumotoKiyoshi(kind: Drug(item: \u0026#34;絆創膏\u0026#34;)) 型消去による解決 associatedtype を持ったオブジェクトを別の型にラップして、associatedtype をジェネリクスで表現できるようにしてみます。こうすることで、Store プロトコル型ではないものの、型宣言からは MatsumotoKiyoshi という具体的な型の情報を消去し、抽象的な AnyStore 型として表現できるようになります。\n/** AnyStore は、Store に準拠したクラスの associatedtype をジェネリクスとして持つ. */ class AnyStore\u0026lt;T\u0026gt;: Store {  // kind の型は、イニシャライザで決まる.  var kind: T   /** 引数として、Store に準拠したオブジェクトを受け取る. where 句で、AnyStore の associatedtype T を引数で受け取ったオブジェクトの T と同じ型としている. */  init\u0026lt;S: Store\u0026gt;(store: S) where T == S.T {  self.kind = store.kind  }   func kindsOfStore() -\u0026gt; T {  return kind  } }  /** 具体型である MatsumotoKiyoshi ではなく、抽象型である AnyStore 型として宣言できている. このように、型消去により具体型情報を消去できていることがわかる. */ var myStore2: AnyStore\u0026lt;Drug\u0026gt;  myStore2 = AnyStore(store: MatsumotoKiyoshi(kind: Drug(item: \u0026#34;絆創膏\u0026#34;))) print(myStore2.kindsOfStore()) 以下のように、配列の宣言としてももちろん利用可能です。\n/** Store に準拠し、associatedtype として Drug を持つオブジェクトを格納できる配列. 型消去により、`MatsumotoKiyoshi` だけでなく `AkaHige` も格納可能. */ var stores: [AnyStore\u0026lt;Drug\u0026gt;]  stores = [  AnyStore(store: MatsumotoKiyoshi(kind: Drug(item: \u0026#34;歯ブラシ\u0026#34;))),  AnyStore(store: AkaHige(kind: Drug(item: \u0026#34;毒マムシドリンク\u0026#34;))), ]  for store in stores {  print(store.kindsOfStore()) } まとめ 実際には、Swift 5.1 で導入された Opaque Types により変数の宣言時に some Store のように表現できるようになりました。 しかし、Opaque Types のままでは抽象型なので利用できない場面（たとえば、配列の宣言に [some Store] とは書けない）があります。この場合には、[AnyStore\u0026lt;Drug\u0026gt;] と記述する必要があります。\nSwiftUI における View 型は、associatedtype を持っているため Opaque Types により some View のように記述します。この View の型消去を行うためのラッパーとして、SwiftUI には AnyView 型が定義されています。\n型消去の仕組み自体は気にしなくても SwiftUI で画面は記述できますが、仕組みを知っておく必要はあるでしょう。 それにより、Opaque Types が何のために存在しているのかも、理解が深まると思います。\n補足 Swift 5.6 では、some に続いて any キーワードが導入されました。 some Store は「 何らかの Store 準拠型」ですが、any Store は「 任意の Store 準拠型」を表します。\nそのため、以下のような宣言も可能です。\n//var someStores: [some Store] // NG var anyStores: [any Store] // OK 参考  「型として」・「制約として」のプロトコルの使い分け | Heart of Swift 型消去の話で出てきたポケモンの例題を理解する #tryswiftconf - Qiita tana000のブログ : 一周遅れのSwift型消去、解説：付属型消去、代替型生成 - livedoor Blog（ブログ） Opaque 型(Opaque Types) · The Swift Programming Language日本語版 swift-evolution/0335-existential-any.md at main · apple/swift-evolution Swift 5.6 の any について \u0026amp; some との違い  "
},
{
	"uri": "https://yagamo-style.com/2022/10/14/swiftui-modifier-order/",
	"title": "SwiftUI のモディファイアの順序による結果の相違",
	"tags": ["iOS", "Swift", "SwiftUI"],
	"description": "",
	"content": "はじめに SwiftUI は、ビューに対してモディファイアをメソッドチェーン形式で追加していくという統一的な操作ができるので、とてもわかりやすいですよね。 時にはモディファイアが多すぎて、見通しが悪くなることはありますが…。\n簡単に扱えるモディファイアですが、順序には注意する必要があります。\n検証環境  macOS Monterey 12.6 Xcode 14.0.0  実験 Text に、frame(), padding(), border() の 3 つのモディファイアを設定してみます。 設定順序の組み合わせは 3! 通りあります。\nサンプルコード それぞれ、枠線を付けた同じサイズの VStack 内に上記 3 つのモディファイアの順序を変えた Text を配置しています。\nimport SwiftUI  struct ContentView: View {  var body: some View {  VStack {  Text(\u0026#34;モディファイアの順序\u0026#34;)  .font(.title)   VStack {  Text(\u0026#34;frame -\u0026gt; border -\u0026gt; padding\u0026#34;)  .frame(width: 300, height: 60)  .border(.red, width: 3)  .padding()  }  .frame(width: 350, height: 100)  .border(.indigo, width: 3)   VStack {  Text(\u0026#34;frame -\u0026gt; padding -\u0026gt; border\u0026#34;)  .frame(width: 300, height: 60)  .padding()  .border(.red, width: 3)  }  .frame(width: 350, height: 100)  .border(.indigo, width: 3)   VStack {  Text(\u0026#34;border -\u0026gt; frame -\u0026gt; padding\u0026#34;)  .border(.red, width: 3)  .frame(width: 300, height: 60)  .padding()  }  .frame(width: 350, height: 100)  .border(.indigo, width: 3)   VStack {  Text(\u0026#34;border -\u0026gt; padding -\u0026gt; frame\u0026#34;)  .border(.red, width: 3)  .padding()  .frame(width: 300, height: 60)  }  .frame(width: 350, height: 100)  .border(.indigo, width: 3)   VStack {  Text(\u0026#34;padding -\u0026gt; frame -\u0026gt; border\u0026#34;)  .padding()  .frame(width: 300, height: 60)  .border(.red, width: 3)  }  .frame(width: 350, height: 100)  .border(.indigo, width: 3)   VStack {  Text(\u0026#34;padding -\u0026gt; border -\u0026gt; frame\u0026#34;)  .padding()  .border(.red, width: 3)  .frame(width: 300, height: 60)  }  .frame(width: 350, height: 100)  .border(.indigo, width: 3)  }  } }  struct ContentView_Previews: PreviewProvider {  static var previews: some View {  ContentView()  } } 結果 考察 border() を最初に設定しているものは、後から設定される frame() や padding() の設定値を知らないので、テキストがちょうど収まるサイズに枠線が引かれていることがわかります。\nこれは、モディファイアが「そのモディファイアの適用結果のビューを返す」メソッドであるためです。 つまり、以下のコードでは\n まずはサイズが設定されていない Text（固有サイズとして文字列がちょうど収まるサイズ）に、枠線を設定 ビューのサイズを幅 300, 高さ 60 に設定 ビューの外側に、標準サイズの余白を設定  という流れとなっています。 そのため、ビューのサイズを設定しているにもかからわず、枠線がそれよりも狭い範囲に引かれているように見えてしまいます。 ですが、「その時点のビューのサイズ」に対しては正しく枠線が設定されていたということになります。\nText(\u0026#34;border -\u0026gt; frame -\u0026gt; padding\u0026#34;)  .border(.red, width: 3)  .frame(width: 300, height: 60)  .padding() まとめ モディファイアは「単にビューに設定を追加するもの」と考えてしまうと順序は関係ないように思えてしまいます。\nですが、あくまでも「モディファイアで設定した結果のビューを返す」という意識があれば、ひとつのモディファイアを実行した結果のビューがその時点で返っているので、最初に border() を持ってくると期待した結果にならないことがわかりますね。\n作成したサンプルは、GitHub: aokiplayer/swift-sandbox/ModifierOrder に置きました。\n参考 Why modifier order matters - a free Hacking with iOS: SwiftUI Edition tutorial\n上記のサイトは、この記事を書いた後に気付きました。 最後に掲載されている、padding() と background() を何度も呼び出すことでサイズの異なる塗りつぶしを重ねるサンプルを実行してみると、この「モディファイアで設定した結果のビューを返す」のイメージがわかりやすいと思います。\n"
},
{
	"uri": "https://yagamo-style.com/tags/iosdc/",
	"title": "iOSDC",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2022/09/12/iosdc2022/",
	"title": "iOSDC Japan 2022 参加レポート",
	"tags": ["iOSDC", "iOS", "Swift"],
	"description": "",
	"content": "不思議なことに、昨年の iOSDC Japan 2021 の終わったのが ほんの数日前のような気がします。\n今回は、熱いうちにレポートを書いておきます。\n公式サイト、ハッシュタグなど  https://iosdc.jp/2022/ @iosdcjp #iosdc  私の参加方針 昨年（2021） 昨年は「とにかくたくさんのトークを聞きたい！」との気持ちで、休むことなくたくさんのトークを聞いてフィードバックしました。 その結果として、ありがたいことにベストフィードバッカー賞を頂きました。\n今年（2022） 3 年ぶりに現地開催もある（オンラインと同時開催）ということで、私は現地で参加しました。 多くのトークを聞きたい気持ちは変わりませんが、現地でしかできない対話を大切にしよう（飢えてる）という思いが強く、また会場と自宅が遠いこともあり、タイムシフトでの視聴はほとんど行いませんでした。\n感想 スポンサーブース スポンサーブースは、全て訪問しました。 みなさん、各社サービスの紹介などもさることながら、抱えている課題や Swift の歴史にかかわる雑談など、たくさんされていました。前回（2019）の時と、印象が変わりました。\nこういう単なる雑談は、ブース要員と来訪者が知り合い同士の場合はよく見かけました（そしてそういう内輪っぽい会話をしている場には近づき難い）が、私のような初対面の人とはあまりしていなかったように思えます。参加者と同じで、コミュニケーションに飢えている部分があったのでしょうか？\nとにかく、スポンサー各社様の内情なども伺えて、とても有意義でした。\nトーク 現地チケットの数を絞ったことから、人気のところにも「満員で入れない」ということはありませんでした。オンライン・オフライン同時開催におけるメリットのひとつですね。ただ、QA の時間はその場では取られなかったので「現地のメリットは？」と思わなくもなかったです。\nトーク内容としては「Swift の文法が大きく変わった」という点を強く感じました。 新規開発で SwiftUI を使った案件が増えたこと、JavaScript などでは当然のように使われてきた async/await などが使えるようになり、コールバック地獄から抜け出せるようになったためでしょうか。\nそういう意味で、もっとも印象に残ったのは たまねぎ さんの「20分でわかる！速習resultBuilder」でした。\nSwiftUI の文法は元々の Swift の文法とは大きく異なりますが、とりあえず「こう書けば良い」で済ましてしまいがちです。 その文法がどうやって成り立っているのか、知ることは大きなステップアップになるでしょう。 SwiftUI で画面を組み立てたれるようになった（SwiftUI の文法に少し慣れた）ら、ぜひ見てみることをお勧めします。\nフィードバックを忘れずに！ これだけ大規模で楽しいカンファレンスが実施できるのは、運営・スポンサー・スピーカーおよびトークの応募者、そして我々参加者の力があってこそです。 昨年の参加レポート にも書きましたが、参加者からのフィードバックがモチベーションとなります。\nまた、スポンサーについては「どれだけブースに立ち寄ってもらえたか」「どれだけアンケートの回答が集まったか」も、次回以降の継続可否に大きく関わります（実体験）。\n トークのフィードバック 全体アンケート スポンサー各社からのアンケート  これらも、忘れずにフィードバックしましょう。\nでは、また次の iOSDC Japan 2023 で会いましょう！（そして私とも仲良くしてください）\n"
},
{
	"uri": "https://yagamo-style.com/2022/09/10/iosdc2021/",
	"title": "iOSDC Japan 2021 参加レポート - ベストフィードバッカー賞を頂きました",
	"tags": ["iOSDC", "iOS", "Swift"],
	"description": "",
	"content": "iOSDC Japan 2022 が、今日から始まりますね。 そんな中、昨年のレポートをいま書いてます。昨年のレポートが終わらないと、今年のイベントが始まりませんからね！\n本レポートでは、セッション内容などの感想には触れません。 私からみなさんに伝えたいのは「ほんの少しでもいいので、スピーカーには感想を伝えよう」だけです。\nありがたいことに、ベストフィードバッカー賞を頂いたので、その点について書いてみたいと思います。\n公式サイト、ハッシュタグなど  https://iosdc.jp/2021/ @iosdcjp #iosdc  モチベーション iOSDC Japan に登壇してイベントを堪能した 2020 年。 しかし、2020 年は私自身に不幸()があり、辛い日々を過ごしていて参加する元気もなく、1,2 セッション覗いただけとなりました。\nその反動で、2021 年は「とにかくセッションをたくさん聞きたい」という気持ちでいっぱいでした。\n私はいかにベストフィードバッカー賞を頂いたのか モチベーションでも書いたように、とにかくたくさんのセッションを聞きたい気持ちが大きかったので、こんな過ごし方をしてました。\n セッションを聞く 次のセッションまでの間は、聞けなかったセッションをニコニコ動画の「追っかけ再生」 その日のクロージング後も「追っかけ再生」 翌日の開始までの間も「追っかけ再生」  こんな感じでした。結果として、全体の 3/4 くらいのセッションは期間中に聞いたのではないかと思います。オンライン参加ならではですね。 もちろん、ただ聞き流すのではなく\n 気づきはメモなども取りながら 楽しかったという気持ちを忘れないうちにフィードバック  を大切にしていました。そのためか、ベストフィードバッカー賞を頂くことができました。\n賞品は Grid 社の AppleWatch の壁掛けです。カッコイイ！\nこんなフィードバックでもいいのかな？ いざフィードバックしようとしても、みなさん気になるのが\n 一言だけのフィードバックなんてもらっても、嬉しくないのでは 自分には内容が難しくて理解できなかったのに、フィードバックしたら申し訳ない 全然的外れなことを書いて、がっかりされないだろうか  などだと思います。\n結論から言うと、そんなことは全くないです。 私は普段から仕事で登壇していますし、iOSDC Japan でも一度登壇していますが、「言葉でフィードバックをもらう」のはどんな些細なものでも嬉しいです（ネガティブなものも含めて）。\n私はあまり人に話しかけるのが得意ではない（カンファレンスの懇親会でもボッチ率が高い）ですし、同じ気持ちの方も多いのではないかと思います。 なら、まずは文字で感想を伝えてみましょう！\n最後に 今日からの iOSDC Japan 2022 は、久しぶりにオフラインも復活です。 文字でのフィードバックだけでなく、ぜひスピーカーの方々に直接感想を伝えてみましょう。文字でも嬉しいですが、直接だともっと嬉しいものですよ。\n"
},
{
	"uri": "https://yagamo-style.com/about/",
	"title": "About",
	"tags": [],
	"description": "",
	"content": " Hiroyuki Aoki トレーナー、インストラクター、トレーニングコンテンツ企画・開発 Swift, Kotlin, Java, iOS, Android, macOS, MDM  Apple Certified Trainer（Apple 認定トレーナー）  2015- macOS Support Essentials (OS X Support Essentials) iOS Deployment Essentials Introduction to Swift Introduction to the iOS SDK App Development with Swift  Apple Professional Learning Provider  2019-2022 学校の先生向けに、授業にアプリケーションやプログラミングを導入する支援を行います  Apple Teacher  2019- Apple Teacher Apple Teacher Swift Playgrounds  トレーニングコンテンツ  速習 Swift プログラミング言語 Swift による iOS アプリ開発入門 Swift による iOS アプリ開発応用 Swift による iOS アプリ開発実践  カンファレンス、セミナー登壇  [iOSDC Japan 2019] 完全に同じ開発環境を素早く用意できる（もしくはできない）技術 [iOS コンソーシアム] Apple Professional Learningを体験しよう ~認定講師によるオンライン研修を無料体験できる特別な4日間~ [iOS コンソーシアム] すぐに始められるiPadの活用研修  その他登壇/出演情報  Schoo  【2017年版】Kotlinで始めるAndroidアプリ開発入門   プログラミング少女  【アンプラグド・プログラミング前編】パソコンを使わないでプログラミングを学ぶ方法って！？ - YouTube 【アンプラグド・プログラミング後編】iPadは誰の手に！？ARの道を早くゴールした方が勝ち！！ - YouTube    "
},
{
	"uri": "https://yagamo-style.com/tags/hugo/",
	"title": "Hugo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2022/03/29/hugo-url-aliases/",
	"title": "Hugo で記事の URL にエイリアスを設定する",
	"tags": ["Hugo"],
	"description": "",
	"content": "はじめに  静的サイトジェネレータ Hugo の設定のお話です 記事が増えると、 Web サイトを整理したくなりますよね。また、 URL を後から変えたくなることもあります。 ただ、そうするとどこかからリンクされているページであればリンク切れを起こしてしまい、全部修正して回る羽目になります 自分のサイト内のリンクであればそれでもいいかも知れませんが、サイト外からリンクされている場合にはそういう訳にもいかないでしょう そのような場合は、記事にエイリアスを設定すれば解決します  検証環境  hugo v0.93.3  エイリアスの設定  ページヘッダの Front Matter に aliases を記載することで、通常の URL に加えて、エイリアスによるアクセスが可能となります 実際には、エイリアスにアクセスすると本来の URL にリダイレクトされます  +++ title = \u0026#34;iOSDC 2019 に Mac の環境構築に関する内容で登壇してきました\u0026#34; date = \u0026#34;2019-09-07T07:33:45+09:00\u0026#34; draft = false toc = true tags = [ \u0026#34;iOSDC\u0026#34;, \u0026#34;iOS\u0026#34;, \u0026#34;Swift\u0026#34;, \u0026#34;macOS\u0026#34; ] aliases = [ \u0026#34;/posts/iosdc2019day1/\u0026#34; ] ogimage = \u0026#34;images/open_graph_logo.png\u0026#34; +++ [iOSDC 2019 に Mac の環境構築の内容で LT 登壇します](/2019/09/03/iosdc2019pre/) で書いていましたが…  上記の記事に設定される本来のパスは /2019/09/07/iosdc2019day1/ ですが、 /posts/iosdc2019day1/ でもアクセスできます 実際にアクセスして、動作を確認してみてください  まとめ  一度公開した Web ページの URL を変えるのは、いろいろと面倒です  でもやりたくなっちゃう   そんな時は、この記事のようにエイリアスで対応しましょう  参考  URL Management | Hugo  "
},
{
	"uri": "https://yagamo-style.com/2022/03/17/hugo-custom-url/",
	"title": "Hugo で記事の URL をカスタマイズ",
	"tags": ["Hugo"],
	"description": "",
	"content": "はじめに  静的サイトジェネレータの Hugo では、記事の URL 階層はデフォルトではディレクトリ階層と一致します ですが、場合によっては変更したい場合があります  ブログ記事などでは、たとえば /diary/2020/04/19 のような形式にしたい場合もあるでしょう そのためにディレクトリを細かく設定していくのは面倒です   その際に、必要な設定について記載します  検証環境  hugo v0.93.3  カスタム URL の指定（Permalinks の設定）  config.toml に [permalinks] 項目を追加することで、記事のパスを自由に設定できます  サンプル [permalinks] posts = \u0026#39;/:year/:month/:day/:filename/\u0026#39;  上記の例では、 contents/posts に配置された各記事の URL は 2020/04/19/拡張子を除いた記事のファイル名/ のような形式となります  出力イメージは、この記事の URL をご覧ください   :year のような設定値は他にも用意されているので、必要に応じて公式サイトで確認すると良いでしょう  まとめ  URL を物理的なディレクトリ階層と分けられれば、記事の管理がグッと楽になります また、途中でディレクトリ階層を変更しても、記事の URL が変わらないのがありがたいですね  参考  URL Management | Hugo  "
},
{
	"uri": "https://yagamo-style.com/tags/git/",
	"title": "Git",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2022/03/16/git-unusual-filename/",
	"title": "いつも忘れる Git の設定（日本語ファイル名を正しく表示）",
	"tags": ["Git"],
	"description": "",
	"content": "はじめに  この記事は、いつも必要だけどいつも忘れる設定なので、単なるメモとして作成してます  Git でリポジトリをクローンしてくるといつも日本語ファイル名がエスケープされて正しく表示されないよね  これを設定しておく（グローバルでやっちゃってもいいとは思うけど）  git config --local core.quotepath false 参考  Git の man より  core.quotePath  Commands that output paths (e.g. ls-files, diff), will quote \u0026#34;unusual\u0026#34; characters in the  pathname by enclosing the pathname in double-quotes and escaping those characters with  backslashes in the same way C escapes control characters (e.g. \\t for TAB, \\n for LF, \\\\ for  backslash) or bytes with values larger than 0x80 (e.g. octal \\302\\265 for \u0026#34;micro\u0026#34; in UTF-8). If  this variable is set to false, bytes higher than 0x80 are not considered \u0026#34;unusual\u0026#34; any more.  Double-quotes, backslash and control characters are always escaped regardless of the setting of  this variable. A simple space character is not considered \u0026#34;unusual\u0026#34;. Many commands can output  pathnames completely verbatim using the -z option. The default value is true. "
},
{
	"uri": "https://yagamo-style.com/tags/json/",
	"title": "JSON",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2022/03/12/json-with-null-value/",
	"title": "プロパティが nil の場合もエンコード先の JSON に属性を出力する",
	"tags": ["iOS", "Swift", "JSON"],
	"description": "",
	"content": "はじめに  JSON の解析をカスタマイズする方法については [ネストした JSON をフラットな構造体にマッピングする] で書きました 「Codable なオブジェクトに nil 値があると、 JSON ではその属性自体が省略されてしまう挙動を変えられないのか？」という質問を受講者から頂いたので、ここに記載しておきます  検証環境  macOS Big Sur 11.6 Xcode 13.2.1  サンプルコード 通常の挙動（nil を含む属性が出力されない） // JSON と対応させる Person 型（Codable に準拠） struct Person: Codable { let name: String let age: Int? // nil を許容 } let encoder = JSONEncoder() let yamada = Person(name: \u0026#34;山田二郎\u0026#34;, age: 53) let kawada = Person(name: \u0026#34;川田吾郎\u0026#34;, age: nil) let yamadaData = try! encoder.encode(yamada) let kawadaData = try! encoder.encode(kawada) print(\u0026#34;==== 値が nil の属性は出力されない ====\u0026#34;) print(String(data: yamadaData, encoding: .utf8)!) print(String(data: kawadaData, encoding: .utf8)!) 実行結果 ==== 値が nil の属性は出力されない ==== {\u0026#34;name\u0026#34;:\u0026#34;山田二郎\u0026#34;,\u0026#34;age\u0026#34;:53} {\u0026#34;name\u0026#34;:\u0026#34;川田吾郎\u0026#34;} nil を含む属性を出力するように変更したもの // JSON と対応させる CustomPerson 型（Codable に準拠） struct CustomPerson: Codable { let name: String let age: Int? // nil を許容 } // Encodable プロトコルの encode(to:) メソッドをオーバーライド // Codable は Encodable \u0026amp; Decodable 型 extension CustomPerson { func encode(to encoder: Encoder) throws { var container = encoder.container(keyedBy: CodingKeys.self) try container.encode(self.name, forKey: .name) // 通常は nil なら無視されるが、明示的にこのフィールドを encode 処理する try container.encode(self.age, forKey: .age) } } let sunagawa = CustomPerson(name: \u0026#34;砂川黄太郎\u0026#34;, age: 87) let umino = CustomPerson(name: \u0026#34;海野泳太郎\u0026#34;, age: nil) let sunagawaData = try! encoder.encode(sunagawa) let uminoData = try! encoder.encode(umino) print(\u0026#34;==== 値が nil の属性も出力される ====\u0026#34;) print(String(data: sunagawaData, encoding: .utf8)!) print(String(data: uminoData, encoding: .utf8)!) 実行結果 ==== 値が nil の属性も出力される ==== {\u0026#34;name\u0026#34;:\u0026#34;砂川黄太郎\u0026#34;,\u0026#34;age\u0026#34;:87} {\u0026#34;name\u0026#34;:\u0026#34;海野泳太郎\u0026#34;,\u0026#34;age\u0026#34;:null} まとめ  encode(to:) をオーバーライドして、全項目を明示的にエンコードするだけなので、それほど難しくはないです  ただ、若干の手間なので、単にエンコード時にプロパティ指定をするなどの方法があると良いですね   サンプルは GitHub に置きました  "
},
{
	"uri": "https://yagamo-style.com/2021/03/08/codable-container/",
	"title": "ネストした JSON をフラットな構造体にマッピングする",
	"tags": ["iOS", "Swift", "JSON"],
	"description": "",
	"content": "はじめに  Swift では Encodable, Decodableプロトコルと JSONEncoder, JSONDecoder を利用すれば、 HTTP 通信で取得した JSON と Swift オブジェクトを一発変換できます🙂 が、ネストした JSON を扱う場合には Swift 側の対応する型（構造体を使うことが多い）も同じ構造にネストする必要があります😔 公開されている Web API では、何階層にもネストしてる JSON も多いので、ネストした階層分だけ構造体を定義するのは面倒ですし、扱いづらくなります そのような場合には、以下の 2 つを実装すると解決できます  Encodable のメソッド encode(to:) Decodable のイニシャライザ init(from:)   定義は少し面倒ですが、一度作成してしまえばとても使いやすくなります  検証環境  macOS Big Sur 11.2.1 Xcode 12.4  サンプル { \u0026#34;user_name\u0026#34;: \u0026#34;山田二郎\u0026#34;, \u0026#34;scores\u0026#34;: [ { \u0026#34;score\u0026#34;: 65 }, { \u0026#34;score\u0026#34;: 24 } ] } 上記の JSON は、構造として全体を表す {} の中に、 \u0026quot;scores\u0026quot; 部分が配列となっており、その要素が {} となっています。 つまり、「オブジェクト」-\u0026gt;「配列」-\u0026gt;「オブジェクト」の 3 階層です。 配列は Swift で Array 型が定義されているので、自分で用意する必要があるのは 2 つの構造体であることがわかります。\nJSON に対応させた構造体（基本） この JSON の階層に単純に対応させるなら、以下のような 2 つの構造体が必要となります。\n// JSONと対応させるPerson型（Codableに準拠） struct Person: Codable { let name: String let scores: [Score] /// SwiftのプロパティとJSONのキーをマッピング enum CodingKeys: String, CodingKey { // case Swift側の名前 = \u0026#34;JSON側のキー\u0026#34; case name = \u0026#34;user_name\u0026#34; case scores } } // Personのプロパティとして利用する型（Codableに準拠） struct Score: Codable { let score: Int } しかし、 \u0026quot;scores\u0026quot; 部分は属性が \u0026quot;score\u0026quot; しかないため、整数の配列にしておいた方が扱いやすそうです。\nJSONに対応させた構造体（階層構造を変更） クラス定義 こんな感じで、 1 階層浅くしたら使いやすそうですね。 \u0026quot;scores\u0026quot; は Int の配列であるため、定義する型は Person のみです。 上のサンプルにある、 Score 型は定義する必要はありません。\n階層ごとの CodingKeys だけは用意しておきましょう。名前は任意です。\n// JSONに対応する構造体 struct Person: Codable { let name: String let scores: [Int] // トップレベルの属性に対応するCodingKeys enum CodingKeys: String, CodingKey { case name = \u0026#34;user_name\u0026#34; case scores } // ネストしたJSONの属性に対応するCodingKeys enum ScoresCodingKeys: String, CodingKey { case score } } このままでは、 JSON と形が異なるため相互変換ができません。 エクステンションで、カスタムデコード用のイニシャライザとカスタムエンコード用のメソッドを追加してみましょう。\nカスタムデコード用の追加実装 extension Person { init(from decoder: Decoder) throws { // CodingKeysを指定し、JSON直下の属性（\u0026#34;user_name\u0026#34;と\u0026#34;scores\u0026#34;にあたる部分）に対するコンテナを取得 let rootContainer = try decoder.container(keyedBy: CodingKeys.self) // JSONのキー\u0026#34;user_name\u0026#34;にあたる部分の値を取得 let name = try rootContainer.decode(String.self, forKey: .name) // ネストしたオブジェクト（キー\u0026#34;scores\u0026#34;）の配列部分（配列なので中身の各要素にはキーがない）のコンテナを取得 var arrayContainer = try rootContainer.nestedUnkeyedContainer(forKey: .scores) var scores: [Int] = [] // 配列の要素の最後になるまで繰り返し while !arrayContainer.isAtEnd { // ネストした部分のCodingKeys（ここではScoresCodingKeys）を指定し配列内のオブジェクト部分のコンテナを取得 let scoreContainer = try arrayContainer.nestedContainer(keyedBy: ScoresCodingKeys.self) // JSONのキー\u0026#34;score\u0026#34;にあたる部分の値を取得 let score = try scoreContainer.decode(Int.self, forKey: .score) // 取得した値を配列に追加 scores.append(score) } // 取得した値をメンバワイズイニシャライザに渡して初期化 self.init(name: name, scores: scores) } } 実装のポイント（JSON -\u0026gt; 構造体）  イニシャライザの引数である Decoder を利用する  解析は、この Decoder を通して行います   Decoder の container(keyedBy:) に CodingKeys を渡して、該当部分のコンテナを取得  CodingKeys が JSON のキー（と、それに対応する構造体のプロパティ名）を保持しているため、そのコンテナを通して値を取得できるようになります   コンテナからは decode(_:forKey:) で CodingKeys に定義したキーを渡して、該当部分の値を取得  コンテナには container(keyedBy:) で CodingKeys が渡っているため、そこに定義したキーで値を取得できます   ネストした部分のコンテナは、上位階層のコンテナから nestedContainer(keyedBy:) や nestedUnkeyedContainer(forKey:) で取得  通常の属性の場合は nestedContainer(keyedBy:) を利用しますが、値が配列の場合には中の各要素にキーがないため、 nestedUnkeyedContainer(forKey:) を利用します   nestedContainer(keyedBy:) を呼び出すごとに、内部的なカーソルが次へ移動する  コンテナの isAtEnd を条件としてループを回せば、要素の回数だけループを回せます そのためループ内で、nestedContainer(keyedBy:) を呼び忘れると無限ループに陥るので注意が必要です    カスタムエンコード用の実装 extension Person { // カスタムでエンコードするためのメソッド func encode(to encoder: Encoder) throws { // CodingKeysを指定し、JSON直下の属性（\u0026#34;user_name\u0026#34;と\u0026#34;scores\u0026#34;にあたる部分）に対するコンテナを取得 var container = encoder.container(keyedBy: CodingKeys.self) // JSONのキー\u0026#34;name\u0026#34;にあたる部分をエンコード try container.encode(self.name, forKey: .name) // ネストしたオブジェクト（キー\u0026#34;scores\u0026#34;）の配列部分（配列なので中身の各要素にはキーがない）のコンテナを取得 var scoresContainer = container.nestedUnkeyedContainer(forKey: .scores) // scores配列をループし、各要素をエンコード for score in scores { // ネストした部分のCodingKeys（ここではScoresCodingKeys）を指定し配列内のオブジェクト部分のコンテナを取得 var arrayContainer = scoresContainer.nestedContainer(keyedBy: ScoresCodingKeys.self) // JSONのキー\u0026#34;score\u0026#34;にあたる部分をエンコード try arrayContainer.encode(score, forKey: .score) } } } 実装のポイント（構造体 -\u0026gt; JSON）  基本的な考え方は、デコードの際と同じです JSON と構造体の構造を注意深く比較し、上の階層から順に処理していけばできると思います  まとめ  階層に合わせて構造体を複数定義しても問題ないですが、フラットな構造の方が扱いやすいですよね 記述量は増えますが、利用する場面のことを考えると、最初に手間をかけておくメリットは十分にあると思います サンプルは GitHub に置きました  参考サイト  Using JSON with Custom Types | Apple Developer Documentation  Playground が用意されているので、動かしながら理解できます    "
},
{
	"uri": "https://yagamo-style.com/2020/12/03/tableview-cell-configure14/",
	"title": "iOS 14 以降の UITableViewCell のレイアウト（カスタムセル非使用）",
	"tags": ["iOS", "Swift"],
	"description": "",
	"content": "はじめに テーブルビューでは、カスタムセルを作成しなくてもデフォルトで提供されている 4 種類のスタイルが利用できました。\n   IB 上での Style 設定 対応する UITableViewCell.CellStyle の定数 説明     Basic default 左端に imageView 、その隣に textLabel   Right Detail value1 左端に imageView 、その隣に textLabel、右端に detailTextLabel   Left Detail value2 左端に textLabel、またそのすぐ隣に detailTextLabel   Subtitle subtitle 左端に imageView 、その隣の上段に textLabel、下段に detailTextLabel    しかし、 iOS 14 では textLabel と detailTextLabel 、そして imageView も deprecated となっています。 その代わりにセルの defaultContentConfiguration() で取得したオブジェクトに設定を行い、それを contentConfiguration プロパティに渡せと書いてあります。 その辺りを、サンプルを書いて確認してみます。\nサンプルプロジェクトは、 GitHub に置きました。\n検証環境  macOS 11.0.1 Big Sur Xcode 12.2 iOS 14.2  サンプル ストーリーボード Example1 シーンではセルの Style を Left Detail に、 Example2 シーンではセルの Style を Custom に設定しています。 サンプルコード Example1 シーンのビューコントローラ セルのスタイルは、 defaultContentConfiguration() によりデフォルトの設定を取得して利用しています。\nimport UIKit  // Table view controller for Example1 scene class Example1TableVC: UITableViewController {  private var items:[(product: String, description: String)] = [  (\u0026#34;AAA\u0026#34;, \u0026#34;aaa aaaaa aaaa\u0026#34;),  (\u0026#34;BBB\u0026#34;, \u0026#34;bbb bbbbb bbbb\u0026#34;),  (\u0026#34;CCC\u0026#34;, \u0026#34;ccc ccccc cccc\u0026#34;),  (\u0026#34;DDD\u0026#34;, \u0026#34;ddd ddddd dddd\u0026#34;),  (\u0026#34;EEE\u0026#34;, \u0026#34;eee eeeee eeee\u0026#34;),  (\u0026#34;FFF\u0026#34;, \u0026#34;fff fffff ffff\u0026#34;),  (\u0026#34;GGG\u0026#34;, \u0026#34;ggg ggggg gggg\u0026#34;),  (\u0026#34;HHH\u0026#34;, \u0026#34;hhh hhhhh hhhh\u0026#34;),  ]   override func viewDidLoad() {  super.viewDidLoad()  }   // MARK:- Table view data source   override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -\u0026gt; Int {  return items.count  }   override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -\u0026gt; UITableViewCell {  let cell = tableView.dequeueReusableCell(withIdentifier: \u0026#34;Ex1Cell\u0026#34;, for: indexPath)   // Use default settings  var content = cell.defaultContentConfiguration()   #if DEBUG  print(content)  #endif   content.text = items[indexPath.row].product  content.secondaryText = items[indexPath.row].description  content.image = UIImage(systemName: \u0026#34;appletv\u0026#34;)   // Set content  cell.contentConfiguration = content   return cell  } } Example2 シーンのビューコントローラ セルのスタイルは、奇数行には UIListContentConfiguration.valueCell() を、偶数行には UIListContentConfiguration.subtitleCell() を利用しています。\nimport UIKit  // Table view controller for Example2 scene class Example2TableVC: UITableViewController {  private var contents: [UIListContentConfiguration] = [  {  var content: UIListContentConfiguration = .valueCell()  content.textProperties.font = .systemFont(ofSize: 20, weight: .heavy)  content.textProperties.color = .systemGreen  content.secondaryTextProperties.font = .monospacedSystemFont(ofSize: 16, weight: .light)  content.secondaryTextProperties.color = .systemOrange  content.imageProperties.tintColor = .systemPurple   return content  }(),  {  var content: UIListContentConfiguration = .subtitleCell()  content.textProperties.font = .systemFont(ofSize: 20, weight: .heavy)  content.textProperties.color = .systemBlue  content.secondaryTextProperties.font = .systemFont(ofSize: 16, weight: .light)  content.secondaryTextProperties.color = .systemTeal  content.imageProperties.tintColor = .systemRed   return content  }()  ]   private var items:[(product: String, description: String)] = [  (\u0026#34;AAA\u0026#34;, \u0026#34;aaa aaaaa aaaa\u0026#34;),  (\u0026#34;BBB\u0026#34;, \u0026#34;bbb bbbbb bbbb\u0026#34;),  (\u0026#34;CCC\u0026#34;, \u0026#34;ccc ccccc cccc\u0026#34;),  (\u0026#34;DDD\u0026#34;, \u0026#34;ddd ddddd dddd\u0026#34;),  (\u0026#34;EEE\u0026#34;, \u0026#34;eee eeeee eeee\u0026#34;),  (\u0026#34;FFF\u0026#34;, \u0026#34;fff fffff ffff\u0026#34;),  (\u0026#34;GGG\u0026#34;, \u0026#34;ggg ggggg gggg\u0026#34;),  (\u0026#34;HHH\u0026#34;, \u0026#34;hhh hhhhh hhhh\u0026#34;),  ]   override func viewDidLoad() {  super.viewDidLoad()  }   // MARK:- Table view data source   override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -\u0026gt; Int {  return items.count  }   override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -\u0026gt; UITableViewCell {  let cell = tableView.dequeueReusableCell(withIdentifier: \u0026#34;Ex2Cell\u0026#34;, for: indexPath)   // Set different UIListContentConfiguration for odd/even cell  var content = contents[indexPath.row % 2]   #if DEBUG  print(content)  #endif   content.text = items[indexPath.row].product  content.secondaryText = items[indexPath.row].description  content.image = UIImage(systemName: \u0026#34;iphone\u0026#34;)   // Set content  cell.contentConfiguration = content   return cell  } } 実行結果 Example1 シーンでは、 Left Detail を指定したにもかかわらず Right Detail 相当の表示となっています。また、フォントサイズなども IB 上の設定とは異なります。 Example2 シーンでは、奇数行/偶数行で別々の設定が適用できています。\nInterfaceBuilder 上の Style 設定はどうなるの？ IB 上で Style を指定してもそのレイアウトになるとは限りません。実際に試してみたところ IB 上で設定した Style は、 UIListContentConfiguration では以下にマッピングされていました。\n   IB 上での Style 設定 UIListContentConfiguration の Base Style 備考     Custom Cell 見た目は Subtitle 相当   Basic Cell 見た目は Subtitle 相当   Right Detail Value Cell 見た目はそのまま Right Detail 相当   Left Detail Value Cell 見た目は Right Detail 相当   Subtitle Subtitle Cell 見た目はそのまま Subtitle 相当    Right Detail と Subtitle 以外は IB 上の見た目と実行時のレイアウトが異なるので注意が必要です。なお、 Right Detail, Subtitle でも、 IB 上で設定したフォントサイズなどは反映されません。 あくまでも、セルのレイアウトはプログラム上でセルの contentConfiguration プロパティに対して設定する必要がありそうですね。\n参考  UITableViewCell | Apple Developer Documentation defaultContentConfiguration() | Apple Developer Documentation  "
},
{
	"uri": "https://yagamo-style.com/2020/11/10/maps/",
	"title": "map と compactMap と flatMap",
	"tags": ["iOS", "Swift"],
	"description": "",
	"content": "はじめに コレクションとかいわゆる「何かの中に値が入ってるやつ」に対する代表的な操作として、 map があります。 が、 map にも亜種があって混乱しがちなので、整理しておきたいと思います。\nなお、この記事では配列を例としています。 実際には、配列でもディクショナリでも Optional でも「入れ物」にあたるものは似たような操作が提供されています（全く同じではないですが）。\nmap の種類 map 配列内の各要素を変換します。全要素を変換するので、変換前後で要素数は変わりません。\ncompactMap map と同じですが、要素のうち nil は除外し、 Optional は unwrap します。 nil を除外するため、 map と異なり変換前後で要素数が変わる（減る）場合もあります。\nflatMap 配列がネストされている場合、内側の配列から要素を取り出して平坦な配列にします（二次元配列 -\u0026gt; 一次元配列）。\n内側の「配列という 入れ物 」を「Optional という 入れ物 」に見立てれば「Optional の内容を取り出した配列」を作成することになり、 compactMap と同じ動作となります。\n Array\u0026lt;Array\u0026lt;要素\u0026gt; -（変換）-\u0026gt; Array\u0026lt;要素\u0026gt; Array\u0026lt;Optional\u0026lt;要素\u0026gt; -（変換）-\u0026gt; Array\u0026lt;要素\u0026gt;  compactMap が実装されていなかった Swift の初期のバージョンではこのような用途でも利用されていましたが、現在では deprecated です。素直に compactMap を使いましょう。\nサンプル map, compactMap, flatMap を利用したサンプルです。 上記 4 つの図と比較しながら読んでみてください。\nコード例 import Foundation  enum Category: String, CustomStringConvertible {  var description: String {  self.rawValue  }   case personal  case business }  struct Item: CustomStringConvertible {  var description: String {  \u0026#34;\u0026#34;\u0026#34; name: \u0026#34;\\(self.name)\u0026#34;, price: \\(self.price), categories: \\(self.categories ?? [])\u0026#34;\u0026#34;\u0026#34;  }   let name: String  let price: Int  let categories: [Category]? }  let items: [Item] = [  Item(name: \u0026#34;Suit\u0026#34;, price: 15000, categories: [.business]),  Item(name: \u0026#34;Pen\u0026#34;, price: 400, categories: [.personal, .business]),  Item(name: \u0026#34;Sea\u0026#34;, price: 99999, categories: nil),  Item(name: \u0026#34;Drink\u0026#34;, price: 120, categories: [.personal]),  Item(name: \u0026#34;Sky\u0026#34;, price: 99999, categories:nil),  Item(name: \u0026#34;Comic\u0026#34;, price: 600, categories: [.personal]) ]  print(\u0026#34;\u0026#34;\u0026#34; == Items ========== \\(items)\u0026#34;\u0026#34;\u0026#34; )  // map transforms each element in an Array. let map = items.map { item in  item.categories ?? [] } print(\u0026#34;\u0026#34;\u0026#34; == map \u0026#34;item.categories ?? []\u0026#34; ========== \\(map)\u0026#34;\u0026#34;\u0026#34; )  // compactMap is a map that only collect non-nil values. let compact = items.compactMap { item in  item.categories } print(\u0026#34;\u0026#34;\u0026#34; == compactMap \u0026#34;item.categories\u0026#34; ========== \\(compact)\u0026#34;\u0026#34;\u0026#34; )  // flatMap flattens the inner Array. let flat1 = items.flatMap { item in  item.categories ?? [] } print(\u0026#34;\u0026#34;\u0026#34; == flatMap \u0026#34;item.categories ?? []\u0026#34; ========== \\(flat1)\u0026#34;\u0026#34;\u0026#34; )  // This type of flatMap is deprecated. You should use compactMap. let flat2 = items.flatMap { item in  item.categories } print(\u0026#34;\u0026#34;\u0026#34; == flatMap \u0026#34;item.categories\u0026#34; ========== \\(flat2)\u0026#34;\u0026#34;\u0026#34; ) 実行結果 == Items ========== [name: \u0026#34;Suit\u0026#34;, price: 15000, categories: [business] , name: \u0026#34;Pen\u0026#34;, price: 400, categories: [personal, business] , name: \u0026#34;Sea\u0026#34;, price: 99999, categories: [] , name: \u0026#34;Drink\u0026#34;, price: 120, categories: [personal] , name: \u0026#34;Sky\u0026#34;, price: 99999, categories: [] , name: \u0026#34;Comic\u0026#34;, price: 600, categories: [personal] ]  == map \u0026#34;item.categories ?? []\u0026#34; ========== [[business], [personal, business], [], [personal], [], [personal]]  == compactMap \u0026#34;item.categories\u0026#34; ========== [[business], [personal, business], [personal], [personal]]  == flatMap \u0026#34;item.categories ?? []\u0026#34; ========== [business, personal, business, personal, personal]  == flatMap \u0026#34;item.categories\u0026#34; ========== [[business], [personal, business], [personal], [personal]] まとめ map については、図で表すとわかりやすいですね。この辺りの操作は Combine フレームワークでもよく使われるので、使いこなせると開発がとても楽になると思います。\n"
},
{
	"uri": "https://yagamo-style.com/2020/07/20/dictionary-to-array/",
	"title": "ディクショナリからタプルの配列を作成する",
	"tags": ["iOS", "Swift"],
	"description": "",
	"content": "はじめに  Swift には、連想配列的なデータ構造としてディクショナリがあります ディクショナリはデータの順序を保証しないので、そのままではテーブルビューやコレクションビューのデータソースとして利用しにくいです その場合は、タプルの配列に変換すると上手く行きます  検証環境  Xcode 11.5 Swift 5.2  利用する機能 sorted(by:)  ディクショナリのメソッド 引数に渡した関数 by がソート条件  関数 by の引数  2 つのタプル（それぞれディクショナリの n 番目の要素と n + 1 番目の要素に対応）   関数 by の戻り値  Bool（false なら並び替え）     戻り値は [(key: ディクショナリの key の型, value: ディクショナリの value の型)]  つまり、ディクショナリとほぼ同じ構造を持った「タプルの配列」    コード例  以下はディクショナリ [String: Int] からタプルの配列 [(key: String, value: Int)] に変換する例です  import Foundation var scores: [String: Int] = [ \u0026#34;Steve Yamada\u0026#34;: 34, \u0026#34;Jeff Takeshita\u0026#34;: 87, \u0026#34;Mickey Yoshida\u0026#34;: 100, \u0026#34;Charly Kinoshita\u0026#34;: 53, \u0026#34;Anna Saito\u0026#34;: 19, \u0026#34;Robert Suzuki\u0026#34;: 97, \u0026#34;Erick Kawakami\u0026#34;: 32, \u0026#34;John Miyabe\u0026#34;: 64, \u0026#34;Gregory Goto\u0026#34;: 76 ] print(\u0026#34;\u0026#34;\u0026#34; Ascending by key ======================== \u0026#34;\u0026#34;\u0026#34;) var sortedByNameAsc: [(key: String, value: Int)] = scores.sorted { $0.key \u0026lt; $1.key } sortedByNameAsc.forEach { print(\u0026#34;\\($0.key): \\($0.value)\u0026#34;) } print(\u0026#34;\u0026#34;\u0026#34; Descending by key ======================== \u0026#34;\u0026#34;\u0026#34;) var sortedByNameDesc: [(key: String, value: Int)] = scores.sorted { $0.key \u0026gt; $1.key } sortedByNameDesc.forEach { print(\u0026#34;\\($0.key): \\($0.value)\u0026#34;) } print(\u0026#34;\u0026#34;\u0026#34; Ascending by value ======================== \u0026#34;\u0026#34;\u0026#34;) var sortedByScoreAsc: [(key: String, value: Int)] = scores.sorted { $0.value \u0026lt; $1.value } sortedByScoreAsc.forEach { print(\u0026#34;\\($0.value): \\($0.key)\u0026#34;) } print(\u0026#34;\u0026#34;\u0026#34; Descending by value ======================== \u0026#34;\u0026#34;\u0026#34;) var sortedByScoreDesc: [(key: String, value: Int)] = scores.sorted { $0.value \u0026gt; $1.value } sortedByScoreDesc.forEach { print(\u0026#34;\\($0.value): \\($0.key)\u0026#34;) } Ascending by key ======================== Anna Saito: 19 Charly Kinoshita: 53 Erick Kawakami: 32 Gregory Goto: 76 Jeff Takeshita: 87 John Miyabe: 64 Mickey Yoshida: 100 Robert Suzuki: 97 Steve Yamada: 34 Descending by key ======================== Steve Yamada: 34 Robert Suzuki: 97 Mickey Yoshida: 100 John Miyabe: 64 Jeff Takeshita: 87 Gregory Goto: 76 Erick Kawakami: 32 Charly Kinoshita: 53 Anna Saito: 19 Ascending by value ======================== 19: Anna Saito 32: Erick Kawakami 34: Steve Yamada 53: Charly Kinoshita 64: John Miyabe 76: Gregory Goto 87: Jeff Takeshita 97: Robert Suzuki 100: Mickey Yoshida Descending by value ======================== 100: Mickey Yoshida 97: Robert Suzuki 87: Jeff Takeshita 76: Gregory Goto 64: John Miyabe 53: Charly Kinoshita 34: Steve Yamada 32: Erick Kawakami 19: Anna Saito まとめ  状況に応じたデータの形式変換をする方法を押さえておくと、いろいろ応用ができそうですね 今回のサンプルは GitHub: aokiplayer/swift-sandbox/SortedDictionary に置きました  "
},
{
	"uri": "https://yagamo-style.com/2020/07/16/arraygrouping/",
	"title": "配列要素をグループ化したディクショナリの作成",
	"tags": ["iOS", "Swift"],
	"description": "",
	"content": "はじめに  テーブルビューやコレクションビューで、グループ化した表示はよく使います その場合、データソースとして二次元配列などを利用すると思います が、データソースが一次元配列だった場合は、少しデータの加工が必要ですよね  検証環境  Xcode 11.5 Swift 5.2  利用する機能 Dictionary(grouping: by:)  ディクショナリのイニシャライザ grouping  元データとなる配列 by で指定した key ごとに、部分配列として分割される   by  グループ化したディクショナリの key となる値を返す関数 引数は、配列の各要素    コード例  配列 [Product] を、 Product の要素である category（Product.Category 型）ごとにグループ化するサンプル 変換後のディクショナリは [Product.Category: [Product]] 型  サンプルコード import Foundation struct Product: CustomStringConvertible { var description: String { \u0026#34;(\\(self.name), $\\(self.price), \\(self.category))\u0026#34; } var name: String var price: Int var category: Category enum Category: String { case food case drink case other } } // Array of Product var products: [Product] = [ Product(name: \u0026#34;Fried Potato\u0026#34;, price: 24, category: .food), Product(name: \u0026#34;Water\u0026#34;, price: 12, category: .drink), Product(name: \u0026#34;Dish\u0026#34;, price: 40, category: .other), Product(name: \u0026#34;Chai\u0026#34;, price: 5, category: .drink), Product(name: \u0026#34;Fork\u0026#34;, price: 56, category: .other), Product(name: \u0026#34;Bread\u0026#34;, price: 35, category: .food), Product(name: \u0026#34;Noodle\u0026#34;, price: 80, category: .food), Product(name: \u0026#34;Coffee\u0026#34;, price: 98, category: .drink), ] print( \u0026#34;\u0026#34;\u0026#34; Elements of Array =========================================== \u0026#34;\u0026#34;\u0026#34; ) products.forEach { print($0) } // Grouping by Category var groupedProducts: [Product.Category: [Product]] = Dictionary( grouping: products, by: { $0.category } ) print( \u0026#34;\u0026#34;\u0026#34; Grouping by Category =========================================== \u0026#34;\u0026#34;\u0026#34; ) groupedProducts.forEach { print( \u0026#34;\u0026#34;\u0026#34; \\($0.key.rawValue) \\($0.value) \u0026#34;\u0026#34;\u0026#34; ) } 出力結果 Elements of Array =========================================== (Fried Potato, $24, food) (Water, $12, drink) (Dish, $40, other) (Chai, $5, drink) (Fork, $56, other) (Bread, $35, food) (Noodle, $80, food) (Coffee, $98, drink) Grouping by Category =========================================== food [(Fried Potato, $24, food), (Bread, $35, food), (Noodle, $80, food)] other [(Dish, $40, other), (Fork, $56, other)] drink [(Water, $12, drink), (Chai, $5, drink), (Coffee, $98, drink)] まとめ  配列要素を任意のグループにまとめられるので、とても便利ですね 今回のサンプルは GitHub: aokiplayer/swift-sandbox/ArrayGrouping に置きました  "
},
{
	"uri": "https://yagamo-style.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2020/03/02/default-modal-segue-xcode11/",
	"title": "iOS/iPadOS 13 のモーダル画面から戻った際に、ライフサイクルメソッドが呼ばれないパターンがある",
	"tags": ["iOS", "Swift"],
	"description": "",
	"content": "はじめに  iOS/iPadOS 13 から、モーダルで画面遷移した際はデフォルトでは全画面ではなく少し小さい表示になります その画面から戻る際、これまでは unwind セグエを呼ぶか dismiss する必要がありましたが、モーダルの画面をスワイプダウンすることで遷移が可能となりました その場合、本来呼ばれるはずのライフサイクルメソッドが呼ばれません  もちろん、 unwind セグエメソッドも呼ばれません unwind セグエから戻っても、ライフサイクルメソッドは呼ばれません（unwind セグエメソッドは呼ばれる）    サンプル 画面レイアウト New Default シーンへのセグエ  Xcode 11 でのデフォルト設定 Presentation が Same as Destination  Full Screen シーンへのセグエ  Presentation を Full Screen に変更 デフォルトと異なり、画面全体を覆う（iOS 12 までの Modal）  ソースコード ViewController（最初の画面） import UIKit  class ViewController: UIViewController {   override func viewDidLoad() {  super.viewDidLoad()  print(#function)  }   override func viewWillDisappear(_ animated: Bool) {  super.viewWillDisappear(animated)  print(#function)  }   override func viewDidDisappear(_ animated: Bool) {  super.viewDidDisappear(animated)  print(#function)  }   override func viewWillAppear(_ animated: Bool) {  super.viewWillAppear(animated)  print(#function)  }  override func viewDidAppear(_ animated: Bool) {  super.viewDidAppear(animated)  print(#function)  }   @IBAction func unwindToMain(_ unwindSegue: UIStoryboardSegue) {  print(\u0026#34;Returned through unwind segue.\u0026#34;)  }   override func prepare(for segue: UIStoryboardSegue, sender: Any?) {  let style: String   switch segue.destination.modalPresentationStyle {  case .automatic:  style = \u0026#34;automatic\u0026#34;  case .currentContext:  style = \u0026#34;currentContext\u0026#34;  case .custom:  style = \u0026#34;custom\u0026#34;  case .formSheet:  style = \u0026#34;formSheet\u0026#34;  case .fullScreen:  style = \u0026#34;fullScreen\u0026#34;  case .none:  style = \u0026#34;none\u0026#34;  case .overCurrentContext:  style = \u0026#34;overCurrentContext\u0026#34;  case .overFullScreen:  style = \u0026#34;overFullScreen\u0026#34;  case .pageSheet:  style = \u0026#34;pageSheet\u0026#34;  case .popover:  style = \u0026#34;popOver\u0026#34;  @unknown default:  fatalError(\u0026#34;Maybe there will be new case.\u0026#34;)  }  print(style)  } } NewDefaultVC（NewDefault ボタンから遷移する画面） import UIKit  class NewDefaultVC: UIViewController {   override func viewDidLoad() {  super.viewDidLoad()  }   override func prepare(for segue: UIStoryboardSegue, sender: Any?) {  print(#file.components(separatedBy: \u0026#34;/\u0026#34;).last!)  } } FullScreenVC（FullScreen ボタンから遷移する画面） import UIKit  class FullScreenVC: UIViewController {   override func viewDidLoad() {  super.viewDidLoad()  }   override func prepare(for segue: UIStoryboardSegue, sender: Any?) {  print(#file.components(separatedBy: \u0026#34;/\u0026#34;).last!)  } } 実行結果 New Default ボタンで遷移 -\u0026gt; Unwind ボタンで戻る pageSheet NewDefaultVC.swift Returned through unwind segue.  unwind セグエメソッドは呼ばれていますが、戻ったシーンのライフサイクルメソッドが呼ばれていません  New Default ボタンで遷移 -\u0026gt; 画面上部からスワイプダウンで戻る pageSheet  やはり、戻ったシーンのライフサイクルメソッドは呼ばれていません また、 unwind セグエを利用していないので、当然ですが unwind セグエメソッドも呼ばれていませんね  同様に、 New Default シーンの prepare(for:sender:) も呼ばれていません    Full Screen ボタンで遷移 -\u0026gt; Unwind ボタンで戻る fullScreen viewWillDisappear(_:) viewDidDisappear(_:) FullScreenVC.swift Returned through unwind segue. viewWillAppear(_:) viewDidAppear(_:)  こちらは、 iOS 12 までと同じですね 戻ったシーンのライフサイクルメソッドおよび unwind セグエメソッドの、どちらも呼ばれています  まとめ  iOS 13 から新しくなったデフォルトのモーダルの挙動は、ユーザにとっては「メインとは別の流れにいる」のを認識しやすいと思います また、スワイプダウンで戻れるので、操作としても直感的です ただ、「戻った際に何か処理をさせる」必要がある場合は要注意ですね 今回のサンプルは、aokiplayer/ModalXcode11 に置きました  "
},
{
	"uri": "https://yagamo-style.com/categories/technical/",
	"title": "Technical",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/tags/apple/",
	"title": "Apple",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2019/12/20/swift-exam-impression/",
	"title": "Apple の iOS/Swift 認定資格を受験してみた",
	"tags": ["iOS", "Swift", "Apple", "Certification"],
	"description": "",
	"content": "2018 年 11 月 26 日の Apple の Newsroom 記事 Apple、Hour of Codeにより、さらに多くの学生にプログラミング教育を提供 - Apple (日本) で述べられているように、 Apple は主に学生をターゲットとした iOS および Swift の認定資格をリリースしました。\n このカリキュラムを履修した学生は、Swiftについての知識、アプリケーション開発ツール、アプリケーションのコアコンポーネントの知識について認定を受けることもできます。App Development with Swift Level 1認定試験は、世界中のCertiport認定試験センターを通じて実施されます。\n 日本ではこれまで試験が配信されていませんでしたが、約 1 年後の 2019 年 12 月 10 日から、 Certiport の代理店である オデッセイ コミュニケーションズ から配信が開始されました。\n配信開始日の一番早い時間に受験し、日本での認定第一号として合格してきました。 興味のある方もいらっしゃると思うので、 NDA に抵触しない程度に感想などをまとめてみます。\nなお、この記事は日本でのリリース当初（2019 年 12 月 10 日）の情報です。 今後のアップデートで、変わる可能性がありますのでご注意ください。\n試験の概要 詳しくは、公式サイトをご覧ください。\n名称 App Development with Swfit Level 1\n試験の範囲 App Development with Swift の内容\n出題数/時間 45 問/50 分\n受験料 一般 ¥9,800, 学生 ¥7,800\n想定されるターゲット層 試験は、主に学生向けのプログラミング学習コンテンツ Everyone Can Code の 1 つとして Apple がリリースしている電子書籍 App Development with Swift に沿った内容です。 ですので、主なターゲットは学生のようです。 受験料も、学生向けには低く設定されています。\n試験の形式 試験の言語 試験は、全て英語で出題されます。 日本語での提供は、現時点では考えていないとのことでした。\n出題形式 基本的に、一般的なオンライン形式の IT 系試験と同じです。 以下のパターンがあります。\n 多岐選択式 選択肢を回答欄にドラッグ 画像の対象部分をクリックしてマーク キーワードを入力  出題の傾向 基本を押さえていれば解ける文法 利用頻度がそれほど高くないものや、フレームワークを作るような人であれば使うが一般の開発者が使う頻度は低いようなもの、などは出題されません。 よく使うもので、かつ最低限の文法を押さえていれば迷わず解けるものばかりです。\nXcode の画面構成の把握 iOS アプリの開発では、 Xcode を利用することが必須です。 そのためなのか、 Xcode のどこからどんな機能が利用できるのか？ということを問われます。\nただし、受験時の最新であった Xcode 11 ではなかったです。 おそらく、 電子書籍（現時点では Xcode 10 対応）のバージョンに合わせているのだと思われます。\n感想 英語での出題に関して Twitter で見ていると「試験が英語だから心配」との声が聞こえてきます。 が、私が受験した感じでは「全く問題ない」です。\n英語とはいえ、「正しい選択肢を選べ」「画面の正しい位置をクリックしてマークしろ」「ドラッグして選択肢を空欄に入れろ」程度です。 あとは Swift や iOS に関する技術用語なので、それはわかるはずです（わからないなら、日本語でも合格できないです）。\n 参考までに、私が以前に一度だけ受けた TOEIC のスコアは 280 点です（Writing: 140, Speaking:140）😑\n 難易度 難易度は決して高くないです。 意地悪な問題は出ないので、 iOS アプリの開発をすでに行っている方であれば、問題なく合格できると思います。 そうでなくても、入門書を 1 冊こなしていれば十分でしょう。\nロジックをじっくり追うような問題はほとんど出ないので、時間も余裕があります。 私は大体 20 分ちょっとで解き終わり、 10 分くらいで見直して終了しました。 「英語を読むのがちょっと遅い」という方でも、時間は十分だと思います。\n出題範囲 App Development with Swift の範囲なので、広くはないです。 携わっているアプリによっては、この本の中で使ってない機能などもあるかと思います。 そこだけキャッチアップしておくと良いかな、と思います。\n例えば、以下の API や機能などは上記の電子書籍で扱っています。\n UITableViewController UIAlertController UIImagePickerController UIActivityViewController SFSafariViewController MFMailComposeViewController MFMessageComposeViewController JSONSerialization Codable JSONDecoder, JSONEncoder PropertyListEncoder, PropertyListDecoder FileManager URLSession NotificationCenter  また、ビューコントローラの各ライフサイクルメソッドで何をするべきか、だったり Auto Layout の基本なども確認しておくと良いでしょう。\nまとめ この試験は難易度的に「エンジニアの能力の証明」よりも「学び始めの人が基本を確認」するような用途に向いていると思います。 App Development with Swift のコンテンツは、思った以上に役に立つ内容が詰まっています。\n「開発には入っているけど、基本の抜けがないか心配」という方は、一度目を通してみると良いでしょう。 その上で、せっかくなので試験も受けてみてはいかがでしょうか？\n"
},
{
	"uri": "https://yagamo-style.com/tags/certification/",
	"title": "Certification",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2019/12/02/adopt-under13-xcode11/",
	"title": "Xcode 11 で作成したプロジェクトを iOS 13 未満に対応させる",
	"tags": ["iOS", "Swift"],
	"description": "",
	"content": "はじめに  Xcode 11 から、新規作成したプロジェクトの構成が変わりました  User Interface を Swift UI と Storyboard から選択可能 SceneDelegate.swift が追加 Info.plist に、 SceneDelegate を利用するエントリが追加   iOS 13 以降のみ対応させる場合にはそのままでよいのですが、多くの場合、 2 つ前くらいまでの iOS をサポートすると思います このままで Target のバージョンに iOS 13 未満を設定すると、エラーが発生して実行できません ここでは、その解決法を紹介します  方法は他にもあるようですが、これが Xcode のサポートを一番受けやすい方法だと思います なお、 Swift UI は iOS 13 以降対応なので、ここでは Storyboard を選択した前提とします    検証環境  Xcode 11.2.1 iOS 13.2.3, 12.3.1 Swift 5  デフォルトの状態と実行確認  プロジェクトを作成すると、以下のような状態となっています   手順 Build Target を iOS 13 未満に設定 アプリを実行  ビルドに失敗する  ビルドエラーメッセージを確認 エラーのアイコンをクリックし、修正内容を選択   SceneDelegate\n クラス全体に @available を付加する修正候補を採用    AppDelegate\n 対象のインスタンスメソッドに @available を付加する修正候補を採用    修正結果（SceneDelegate.swift）\n  import UIKit  @available(iOS 13.0, *) class SceneDelegate: UIResponder, UIWindowSceneDelegate {   var window: UIWindow?   〜省略〜  }  修正結果（AppDelegate.swift）  import UIKit  @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate {   〜省略〜   // MARK:UISceneSession Lifecycle   @available(iOS 13.0, *)  func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -\u0026gt; UISceneConfiguration {  // Called when a new scene session is being created.  // Use this method to select a configuration to create the new scene with.  return UISceneConfiguration(name: \u0026#34;Default Configuration\u0026#34;, sessionRole: connectingSceneSession.role)  }   @available(iOS 13.0, *)  func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set\u0026lt;UISceneSession\u0026gt;) {  // Called when the user discards a scene session.  // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.  // Use this method to release any resources that were specific to the discarded scenes, as they will not return.  }   } 再度、アプリを実行  実行できるが、画面は真っ黒  Xcode のコンソールを確認  以下のようなメッセージが表示されている  2019-12-03 10:29:13.671826+0900 SampleProject[309:24561] [Application] The app delegate must implement the window property if it wants to use a main storyboard file.  ストーリーボードを利用するためには AppDelegate に window プロパティが必要とのメッセージ 以前のバージョンの Xcode で作成したプロジェクトでは、宣言されていた  AppDelegate に window プロパティを追加  SceneDelegate に記載されている内容を、そのまま移植すれば OK 修正結果（AppDelegate.swift）  import UIKit  @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate {   var window: UIWindow?    〜省略〜 } 実行して、動作することを確認  Main.storyboard の最初のシーンが表示される  まとめ  基本的には、 Xcode の修正候補に従って修正すれば問題ないです 今回のサンプルは、 GitHub に置きました  aokiplayer/Under13Xcode11Sample   これ以外に、今後は Swift UI とストーリーボードを混在させる必要が出てくると考えられます  Swift UI を使いたいが、 iOS 13 未満もサポートしたいパターン   複数バージョンに対応させる方法は、調べておきましょう  "
},
{
	"uri": "https://yagamo-style.com/2019/10/15/asr-restore-basic/",
	"title": "asr restore による Mac の起動ボリュームのリストア",
	"tags": ["macOS"],
	"description": "",
	"content": "はじめに  Apple 標準の asr コマンドを利用して、 Mac の起動ボリューム（デフォルトでは Macintosh HD）をリストアする方法です とはいえ、起動ボリュームか否かは関係なく、どのボリュームでも扱い方は同じです  むしろ、起動可能なボリュームのイメージ作成の方にコツがある 今回は、イメージ作成についての詳細には触れません    検証環境  MacBook Pro without T2 Security Chip (-2017) MacBook Pro with T2 Security Chip (2018-) macOS Mojave 10.14.6  asr コマンド  asr は、 Apple Software Restore の略であり、その名の通りリストアを目的としたコマンドです Apple がどこまで公式にサポートしているのかはわかりませんが、起動ボリューム自体もリストア可能です  ソースとなるディスクイメージの作成方法にコツがあったり、いろいろ苦労はありますが…   主に利用するのは、 asr restore の形式です  asr restore  asr restore は、以下のような形式で記述します  asr restore --source リカバリ元のディスクイメージやボリューム --target リカバリ先のディスクやボリューム --erase オプションの説明  --source or -s  リカバリ元のソースを指定 ディスクイメージ でもいいし、それをマウントしたボリュームでも OK  DMG 形式はそのまま指定できるが、 Sparse Bundle などではマウントしなければ指定不可能     --target or -t  リカバリ先のターゲットを指定 /Volume/... のようにボリュームを指定しても、 /disk/disk1s2 のようにディスクを指定する形式でも OK   --erase リストア先のデータを削除する  利用例 トレーニング用に複数 Mac をリストアする  iOSDC 2019 に Mac の環境構築に関する内容で登壇してきました でご紹介したように、トレーニング環境のセットアップに利用しています  全受講者の環境を、完全に揃えることができるメリットは大きいです iOSDC での発表時から、利用する方法は若干変わってます（T2 Security Chip 搭載の Mac への対応のため）    手順  あらかじめ、全 Mac にパーティションを切っておく（ここでは Setup というパーティションとする） Carbon Copy Cloner （以下、 CCC）を使って、リストアイメージを格納したディスクイメージを作成する（ここでは Setup.sparsebundle とする）  CCC を利用するのは、 Disk Utility で作成したイメージから戻すと bless に失敗して起動できず、その対処方法がわからなかったためです T2 Security Chip あり/なしの Mac 間では、同じイメージを使い回すことはできません   イメージを全リストア対象の Mac の Setup パーティションにコピーする（残念ながらここは手作業） asr restore でリストア（2,3 分で完了）  最後に  Apple としてはモノリシックイメージからのリストアは推奨していないものの、 asr コマンドについては WWDC 2019 のセッションで紹介しています  What\u0026rsquo;s New in Apple File Systems   APFS や T2 Security Chip との付き合い方は考える必要がありますが、学校やトレーニング企業ではイメージからのリストアは必須なので、今後も引き続き使い方を探っていきます  "
},
{
	"uri": "https://yagamo-style.com/tags/macos/",
	"title": "macOS",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2019/09/08/iosdc2019day2/",
	"title": "iOSDC 2019 に参加してきました",
	"tags": ["iOSDC", "iOS", "Swift", "macOS"],
	"description": "",
	"content": "2.5 日間にわたって開催されていた iOSDC 2019 が終了しました。正確には、今はまだこのブログを書いている途中なので終了ではないですが（\u0026ldquo;ブログを書くまでが iOSDC\u0026rdquo;）。\n私自身の登壇に関しては、前回のエントリ iOSDC 2019 に Mac の環境構築に関する内容で登壇してきました をぜひご覧ください。\nここでは、それ以外について振り返りたいと思います。\n公式サイト、ハッシュタグなど  https://iosdc.jp/2019/ @iosdcjp #iosdc  イベント全体について もちろん、最高のスタッフで全体的に素晴らしかったです！ が、いくつかピックアップします。\n良かったこと 公式アプリ  アプリ自体も良かったですし、フィードバックを素早く反映されていてすごいなと思いました 具体的には、練習会のときに「スピーカーだけじゃなくて、スタッフの方の Twitter リンクはないのですか？」とお伝えしたら直後のリリースで対応されていました！  ネットワーク  毎年改善が目覚ましいです ごく短時間、繋がりにくいのと WiFi の先でインターネットに接続できないこともありましたが、ほぼ問題なく接続できていました  1,000 人越えのしかもコミュニティベースのイベントで、これは本当にすごいなと思います   Aruba の最新の機器をこのカンファレンスで（たぶん）国内初の利用とか、気合入ってますね！  映像技術  登壇者のスライドとそこから切り替えてデモ実施時の映像、登壇者の映像をセッションタイトル付きの枠にその場で合成して配信してました また、スライドの縦横比によって即座に切り替えたりも ボーッとしてると当たり前のように思えますが、冷静に考えてとてもすごい！  スピーカーディナーでの 1min ピッチ  文章からだけじゃなくて、動画でトークの内容を事前に宣伝する試みは面白いなと思いました スピーカーの立場としても、これを行うことで話す練習にもなるし、考えをまとめるいい機会になりました  ルーキーズ LT 練習会  Twitter や別のエントリで何度も書いてますが、これは練習という意味だけでなく最高でした！ 練習会の参加者（スピーカーだけじゃなくてスタッフの皆さん）は、顔を合わせるたびに話が盛り上がる感じになってました どなたかがツイートしていましたが、この \u0026ldquo;文化祭\u0026rdquo; みたいな感じがすごくいいなーと思いました この練習会は、次に採択されてももう二度と参加できないのが寂しいです😢  座席予約  個人サポーターおよびジョーカーチケットを持ってる人が、あらかじめ聞きたいセッションの席を予約できるシステムです 人気のセッションは前のセッションを諦めて並ぶ必要があったりしたけど、それを（ある程度）解消できます 私は並ぶのが苦手なタイプなので、これはありがたかったです！  オープニングパーティ、茶会、懇親会  交流を測る場としては同じだけど、それぞれコンセプトが違っていて楽しかったです  オープニングパーティは話す、というよりもみんなで踊って楽しむ（音量大きめ） 茶会は \u0026ldquo;ノンアルコールがマジョリティ\u0026rdquo;。着席でカテゴリ別のテーブルや、ボードゲームなどもあり 懇親会は立食で、いわゆる普通の懇親会   多くのカンファレンスは最終日の懇親会のみだけなので都合がつかないこともあるけど、複数あると参加できる可能性が増えていいですね  もっと良くできるかも iOSDC チャレンジ  これ自体は、ゲーム性があってとても楽しいものでした トークンを探すために、多くのスポンサーブースにも自然と足が向くという、よく考えられた仕組みです  2017 年の、スポンサーロゴ缶バッジと近いですね   が、例年の自分の行動と照らし合わせてみると、いつもであれば聞いたセッションのフィードバックをしていた時間を、トークン探しに費やしていました そのため、聞いてすぐにフィードバックが送れず、ほとんどは全日程が終わった後に書くことになりました そこは、どちらを優先するかの参加者の問題なので、私の考え方次第ですね  セッションのバランス  これも感じ方次第なのですが、 iOS やその周辺技術以外のトークが比較的固まっている時間帯がありました  最終日 LT の後半   全体からすると割合はそこまで多くなかったと思うのですが、印象的にそう見えてしまった感じがします でも、トークの題材を限定しすぎるよりも自分の知らなかったいろんな内容を知るのは楽しいです！  茶会の流動性  茶会は基本、着席でテーブルを囲んで話すスタイルでした そのため、人の流動性は少なく、多くの人との交流という点ではちょっともったいなかったです  意図して動かないというわけではなくて、座ってるとじっくり話し込んじゃって気付いたら時間が経過している   どなたか言ってましたが、スタッフが途中でアナウンスをしてみてもいいのかなと思いました  名札のプロフィール QR  参加者同士のアカウント交換しやすいように、名札に fortee のアカウント情報へアクセスする QR コードが付いていました これはすごく便利！だったのですが、私は活用できていませんでした（活用したつもりになっていました） スピーカー情報を登録していたので、それが表示されるものと思っていたのですが、それとは別に入力が必要でした それに気付いたのが終盤だったので、私の QR コードを読み込んでくださっていた方々は無を見ていたことになります… スピーカーに対して、「スピーカー情報だけ入力してもダメだよ」とのアナウンスが事前にあると良かったかも知れません  次回への抱負  今回の私のトークは「試行錯誤してる」状態で終わってしまいました 引き続き試すので、そこで得られた知見などをまたお話ししたいなと思ってます 今回は参加できなかった、企業スポンサーとしてもまた帰って来るために組織もなんとかしたい…  参加したセッションについての一言感想 たくさん感想はあるのですが、ものすごい量になりそうなのでそれぞれ一言だけ感想を書きます。\nday 0 - 前夜祭 普通に書くと即メモリーリーク！こんなに大変だけど俺はXamarin.iOSを使い続けるぜ！  Xamarin.iOS は、何だかんだ言っても考慮することが多くてすっごく大変。でも技術や探究が好きな人には最高に楽しめそう  day 1 めくるめくシェーダアートの世界  難しそうなイメージがあったけど、簡単な処理であればすぐにでも試すことができそう。記憶の彼方にある（もうないかも）行列などを思い出すきっかけになる気がします  ランチセッション（ランチスポンサー: CREW 様）  ユーザからの 5 段階評価は基準がブレるので難しいのはすごく納得。「こんなことがあったら 4」みたいに、例示をするのは確かに良さそう  Swiftクリーンコードアドベンチャー　~日々の苦悩を乗り越え、確かな選択をするために~  丁寧な例示があったので、まずはなぞってやってみたい。 Swift では全然ジェネリクスを活用できてないので、それもキャッチアップしつつかな  画像処理における、UIImageとCGImageとCIImageの効果的な使い分け  UIImage しか使ってこなかった、かつカメラ機能なんていつ実装したかな勢なので、またやってみたい。リサイズは絶対必要になるし、そのときは今回の知見が役立ちそう  iOSアプリのリジェクトリスクを早期に発見するための取り組み  ipa ファイルの中身を詳しく見たことはなかったので、そこまでいろいろ情報が取れるとは思ってなかった。しかもそれをもとにチェックツールを作ってしまうとは。これは欲しい！  LT - Track A 日本のサマータイムに苦しめられた話  サマータイム実施してた年の特定日時だけ特別対応が必要とか、すごく大変。これって、定常的にサマータイムやってる国の情報だったら問題ないのかな？  Property Delegatesがもたらす新しいSwiftプログラミング  この秋までに理解が必須な、新しい言語仕様。だけど理解が追いついてない。サンプルに挙げて頂いたコードを読み直そう  LLDBデバッガで不具合の原因を特定して開発速度を上げよう  po しか使ってなかった人のための技術。 LLDB のコマンド、いろいろ使おうと思いつつ今に至るので、これをきっかけにまずは発表にあった v とか使ってみよう  Core MLで実現する爆速のARサイズ計測  サイズ計測の精度を上げるのが大変そうだけど、それができたら本当に使いやすそう。撮影条件さえ整えば、このままでも実用に耐えられそう。こうやって実際に役立つ場面があると、すごく試したくなります  1ヶ月半でプッシュ通知許諾率を17％から40％にあげた話  まさに試行錯誤って感じでした。やっぱり、シンプルな方法はストレートに効いてくるのがわかりました  もし文系卒の女子エンジニアが 5年もののiOSアプリにユニットテストを導入しようとしたら  最初から壮大な夢を描いて完璧を求めるんじゃなくて、できるところからやることの重要さがよく伝わりました。私も、できるところからやろう  AR Quick Lookを家具ECサイトに導入した話  AR Quick Look は全く使ったことがなかったけど、意外と簡単に使えそう。やっぱり、ブラウザで AR ってユーザにとっては気軽だしいいよね！  個人開発のアプリが輝くために  アプリそのものが良くても、検索にヒットしないともったいない。その後の茶会で、実際にそういう例に遭遇してなるほど！と思いました  GitLabRunnerで始める自前CI環境  弊社も GitLab 立ててる（Mac ではないけど）ので、やってみたくなった。トレーニングで使わなくなった、ちょっと古い Mac で試してみようかな？  Swiftでつくるファミコンエミュレータのススメ  Swift には unsigned があるから、エミュレータに適しているらしいです。それは俄然興味が湧きます。 Swift の夢が広がりますね  day 2 iOSアプリに「意識」は宿るのか？ディープラーニングの先にある人工知能（AI）  脳そのものについての説明が多く、生物学好きな私にはとても興味深い内容でした。 AI を理解するには、やはりそこまで学ぶ必要があるんですね  今こそwatchOS  通知の確認と Suica 以外、なかなか活用されない（あとは時間を見る） Apple Watch ですが、思ったよりできることが増えてました。あの画面上で、 3D モデルがグリグリ動くのはテンション上がりますね！  多言語対応と戦う 2019年版  多言語対応、いつも「どこまで分解するか」悩むけど、その辺りの指針もあっていい感じでした。でも実は多言語対応とかしてないので、そろそろやってみるかな  LT - Track A + B 俺たちのARKitでめちゃめちゃ表情豊かなVTuber向け表情トラッカーを作るぞ  顔のトラッキングで、数十個もの特徴点？があるのは知りませんでした。この辺の技術も、一度試しておきたいです  iOS 12以下でDark modeに対応した地獄の話  Dark Mode のことを考えているか？と言われたら No なので、その対応を考えさせられる内容でした。 Dark Mode にも対応した Type は使いやすいエディタなのでみんな使おう！  Swiftのスタック変数とCPUレジスタの関係を読み解いた  やっぱり低レイヤーの処理って、知っておいた方がいいのかな？とても楽しそうにお話しされてたので、触れてみたくなりました  モノレポで複数アプリをリリースする場合のGit運用戦略  複数アプリで共通するようなコードは、現時点ではあまり持ってないけど、将来のために試してみようかな？  SwiftUIでの開発に向けた我々が出来る既存アプリのリファクタリング  コンポーネントをしっかり分けておけば影響範囲は最小限に抑えられる、というお話でした。が、さて自分のコードを省みると…  ARKitの壁認識で、壁にぶち当たった話  ARKit の面白さと、特徴の少ない床や壁への対応の大変さがよくわかりました。スタンドを立てて、最後にそれを消せばいいとは。発想の転換ですね！  iOSDCのプロポーサル判別器をつくろう  プロポーザルの生成ではすごい文章がで出来上がっていました。いずれはこれらの技術の精度が上がると思うと、これは興味深いです  Write the \u0026ldquo;code\u0026rdquo;, Change the world. 〜エンジニアと法律〜  技術が正しく使われて発展しやすい環境を作るには、我々のような技術を理解した者の働きかけが必要なんですね。今まで考えもしませんでした  Getting Started with Swift WebAssembly  Swift がブラウザ上でも使えるようになると思うと、テンションが上がります。簡単には行かなさそうですが、望みはありそうで楽しみです  これデフォルトで作れないんだ！？を解消した話  デザイナーとエンジニア間の、認識の齟齬を解消する取り組みの話でした。仕組みとして取り入れて実際に改善するのが、やはり重要ですね  フィードやチャットのスクロール\u0008を全力でなめらかにする  テキストの内容でセルの高さをあらかじめ計算する、という内容でした。少しコード量は増えますが、パフォーマンスが改善するなら、やってみる価値はありそうですね  令和時代のゲームボーイ開発 👾  ゲームボーイの実機で動くものが作れるのは、とても魅力的です。実装言語が Swift だったら、もっと良かったですね  "
},
{
	"uri": "https://yagamo-style.com/2019/09/07/iosdc2019day1/",
	"title": "iOSDC 2019 に Mac の環境構築に関する内容で登壇してきました",
	"tags": ["iOSDC", "iOS", "Swift", "macOS"],
	"description": "",
	"content": "iOSDC 2019 に Mac の環境構築の内容で LT 登壇します で書いていましたが、ルーキーズ LT に登壇してきました。 普段からトレーニングで話してはいますが、全くの別物なのでずっと緊張してました。\n若干のミス（残り時間を間違えて、 15 秒余らせたまま最後の部分を省略してしまった）はあったものの、お伝えできたかなと思います。\n公式サイト、ハッシュタグなど  https://iosdc.jp/2019/ @iosdcjp #iosdc  発表スライド Speaker Deck に上げたので、ぜひご覧ください。\n 完全に同じ開発環境を素早く用意できる（もしくはできない）技術  モチベーション トレーニングの環境作成って、とても気をつかいます。特に、 Mac を使うトレーニングの場合、多くの受講者が Windows しか触ったことがないです。 そのため、トレーナーがデモしている環境と、受講者の環境にちょっとでも差があると、受講者はとても戸惑います。 なので、環境は少しの違いもなく揃えておく必要があります。\nただし、全部手作業で行うのは効率的ではなく、ミスも発生します。それに、セットアップ自体は技術に長けた我々トレーナーではなく、別の部隊です。なので、技術的に難しい手順は踏ませられません。\n話したこと いかにミスを防ぎ、大量の Mac を素早く正確にセットアップするかという点について、これまで取ってきた様々な手法についてお話ししました。 現在、残念ながら以前と比較して手間のかかる方式で行わざるを得ず、まだ模索している状況です。 それも含め、現状をお伝えしました。\n紹介した技術 Apple の提供する機能 NetRestore  macOS Server の 1 機能として提供されていました  Apple の「モノリシックイメージからのリストアは推奨しない」方針により、現在は利用できません macOS Server にはまだ機能が残っていますが、 GUI の画面は削除されました 2018 年以降（T2 Security Chip搭載）の Mac ではネットワークブート機能が削除されたため、 NetRestore が機能したとしても、各 Mac からは NetRestore イメージにはアクセスできません   事前に作成しておいたシステムイメージと完全に同じ環境がリストアできます とても素早い（リストア開始から完了まで 5,6 分）  Time Machine  履歴を持ったバックアップを取れる機能です 基本的に、同じバックアップから複数の Mac をリストアすることは前提にしていません  そのためか、複数の Mac から同時にリストアできません   Time Machine からのリストアは、 NetRestore のようなブロックコピーではないので時間がかかります  MDM(Mobile Device Management)  社内で iOS を集中管理する際などに利用しますが、 macOS にも対応しています Configuration Profile に設定を記述し、それをサーバからプッシュすることで設定を強制します Apple Business Manager(ABM) と連携することで、 VPP(Volume Purchase Program) で購入した App Store のアプリのインストールを各クライアントに強制できます  ただし、 App Store にある最新のアプリがインストールされるため、「チームで Xcode のバージョンを固定している」場合などには別の策を取る必要があります   ABM は、 VPP と DEP を統合したものです  VPP(Volume Purchase Program) DEP(Device Enrollment Program)    ASR(Apple Software Restore)  今回紹介した技術の中では NetRestore 以外唯一、インストールではなくイメージのコピーを行う技術  なので、リストアは速いです（数分） ただし、イメージは各 Mac に個別にコピーしておく必要があります   Disk Utility を利用してシステムのイメージを DMG ファイルとして作成し、それをもとに macOS Recovery 上でコマンドラインからリストアします macOS 10.14 Mojave まではうまく動作したのですが、 10.14.1 以降必ず失敗するので、断念しました  原因は追い切れていないので、場合によってはまた利用できるかもしれません    サードパーティの機能 AutoDMG  現在、暫定的に利用している機能です macOS のインストーラをカスタマイズし、/Applications へ配置したいアプリケーションなどはあらかじめ仕込んでおくことができます  通常手順での Xcode のインストールなどは非常に時間がかかる（ダウンロード、 xip の展開）ので、その時間をなくすことができます そのため、「クリーンインストールして、アプリを手動インストール」よりはだいぶマシです   各種設定はできない（クリーンインストールと同じで、 macOS インストール後のユーザの作成から先は手作業）ので、 Configuration Profile やシェルスクリプト で対応しています macOS の設定を行うコマンドとしては、以下などを利用しています  defaults コマンド  ユーザの設定を管理するコマンド   scutil コマンド  システムの設定を管理するコマンド      登壇した感想 内容的にあまり刺さる方はいないだろうな、とは思っていましたが、 Twitter や対面で感想を頂くことができました。 誰か 1 人でも、役に立った（もしくは面白かった）と思って頂けたなら、話した意味はあったのかな、と思います。\nまた、特にルーキーズ LT では、事前に運営側主催で練習会を開いて頂き、アドバイスも頂けました。 その際に、練習会参加者同士の繋がりも生まれ、良い仲間ができました。\n運営側、そしてルーキーズ仲間には本当に感謝しています。もちろん、私の LT を聞いて頂いた皆さま、このポストを読んで下さった皆さま、ありがとうございます。\n本当に iOSDC は楽しいので、次はあなたもぜひトークに応募してみてください！\n勉強会会場\u0026amp;機材お貸ししてます 都内で勉強会を開きたい方、ご連絡ください！ セミナールームだけではなく、 MacBook Pro や iPad などもご利用頂けます。 try! Swift のワークショップでご利用頂いた実績もあります。どうぞ、お気軽に声をかけてください。\n"
},
{
	"uri": "https://yagamo-style.com/2019/09/03/iosdc2019pre/",
	"title": "iOSDC 2019 に Mac の環境構築の内容で LT 登壇します",
	"tags": ["iOSDC", "iOS", "Swift", "macOS"],
	"description": "",
	"content": "2016 年の初回開催から参加している、 iOSDC に今年も参加します（9/5-7 開催）。 昨年までは個人サポーター（およびスポンサー企業の社員）として参加していましたが、今年は LT に登壇します！ なので、スピーカー兼個人サポーターとしての参加です（今期から、弊社は技術系のカンファレンスにスポンサーを出さない方針になってしまいました…）。\n公式サイト、ハッシュタグなど  https://iosdc.jp/2019/ @iosdcjp #iosdc  私（Hiroyuki Aoki）について  株式会社カサレアルで、研修のトレーナーをしています iOS や Android アプリ開発コースも担当していますが、国内唯一の Apple 認定トレーナーとして macOS のシステム管理コースなども担当しています  ちなみに、カサレアルは国内唯一の Apple 認定トレーニングプロバイダーです Apple の macOS 認定資格（Apple Certified Support Professional）の試験も、弊社で受験可能です   業務を行う中で得た知見から、今回の LT では Mac の環境構築に関する内容を話します  こんなことを話します 完全に同じ開発環境を素早く用意できる（もしくはできない）技術  弊社では、トレーニングで利用するために、たくさんの Mac を全部同じ状態にセットアップしています 手作業で設定すると、ちょっとずつ設定がズレてしまい、受講者に同じ体験をして頂くことができません そのため、素早く・簡単に・完全に同じ状態の Mac をセットアップする必要性があります 以前は利用できた方法が使えなくなったりと一筋縄では行かないのですが、これまでどうやってきて今後どうして行くのか、お話しします  私の登壇は 9 月 6 日の 16:35 、 Track Aの LT 前半の最後です。 アプリの開発技術ではないですが、 Mac の設定も奥が深くて楽しいですよ！ それに、みなさんの普段の Mac 環境準備にも、もしかしたら役に立つ情報があるかも知れません。\niOSDC の好きなところ このイベントは、参加者同士のコミュニケーションを特に大事にしていて、「パックマンルール」や「機械的席詰めタイム」など、面白い取り組みをたくさん取り入れています。 また、ルーキーズ LT 練習会を開催して、初めて登壇する人がより良いプレゼンをできるようにサポートしてくれたりもしています。 このように、参加者のことを本当に大事にしている、誰でも楽しめるイベントです。\nぜひお話ししましょう iOSDC は、参加者同士のコミュニケーションを特に大事にしている、私の大好きなカンファレンスです。 私を見つけたら、ぜひ声をかけてください。とても喜びます！\n"
},
{
	"uri": "https://yagamo-style.com/tags/mac/",
	"title": "Mac",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2019/08/02/getmacaddress/",
	"title": "MACアドレスを取得してファイルに書き出すシェルスクリプト",
	"tags": ["Mac", "Shell Script"],
	"description": "",
	"content": "はじめに  トレーニングをお客様先で実施する際、持ち込んだMacを現地のWiFiに接続するためにMACアドレスを求められる場合があります 未認証のデバイスを接続させないため、MACアドレスでフィルタリングを掛ける目的です 手作業で取得するのは辛いので、シェルスクリプトを用意しました あとで集約する際のために、ファイル名にはMacのSerial Numberを付けるようにしました  検証環境  macOS 10.14.6 Mojave  シェルスクリプトの内容 #!/bin/sh  ## GET Serial Number of this Mac SERIAL=`ioreg -l | awk \u0026#39;/IOPlatformSerialNumber/ { if (gsub(/\u0026#34;/, \u0026#34;\u0026#34;)) print $4 }\u0026#39;`  ## Write MAC address of primary WiFi interfce in \u0026#34;{SERIAL NUMBER}.txt\u0026#34; on this user\u0026#39;s Desktop ifconfig en0 ether | awk \u0026#39;/ether/ { print $2 }\u0026#39; \u0026gt; ~/Desktop/${SERIAL}.txt Serial Numberを取得して、変数に代入 SERIAL=`ioreg -l | awk \u0026#39;/IOPlatformSerialNumber/ { if (gsub(/\u0026#34;/, \u0026#34;\u0026#34;)) print $4 }\u0026#39;`  ioregで、ハードウェアデバイスとドライバの情報を取得 awkを利用して、以下の処理を実行  IOPlatformSerialNumberを含む行だけを抽出  　| \u0026quot;IOPlatformSerialNumber\u0026quot; = \u0026quot;C0XXXXXXXXXX\u0026quot;   \u0026quot;を除去する  　| IOPlatformSerialNumber = C0XXXXXXXXXX   スペースで区切った4つ目のフィールドを出力  C0XXXXXXXXXX      WiFiインターフェイスのMACアドレスを取得し、ファイルに書き込み ifconfig en0 ether | awk \u0026#39;/ether/ { print $2 }\u0026#39; \u0026gt; ~/Desktop/${SERIAL}.txt  ifconfigでインターフェイスを指定して、MACアドレスの情報を取得 awkを利用して、以下の処理を実行  etherを含む行だけを抽出  　ether XX:XX:XX:XX:XX:XX　   スペースで区切った2つ目のフィールドを出力  XX:XX:XX:XX:XX:XX     デスクトップ上の、ファイル名{Serial Number}.txtのファイルに書き込み  最後に  awkとか正規表現とか、いまだに苦手です 「こう書いたほうがいいよ」などあれば、教えてください！ 作成したシェルスクリプト は、aokiplayer/scriptsに置きました  "
},
{
	"uri": "https://yagamo-style.com/tags/shell-script/",
	"title": "Shell Script",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2019/07/02/delegate/",
	"title": "簡単なdelegateのサンプル",
	"tags": ["iOS", "Swift"],
	"description": "",
	"content": "はじめに  iOSアプリでは、delegateが非常によく利用されます トレーニングで紹介していると、初めての人には「delegateオブジェクトに用意したコールバックメソッドが自動的に呼ばれる」ことの理解が難しいように感じました そこで、ごく簡単なサンプルを利用してdelegateの仕組みを紹介してみます  検証環境  Xcode 10.2 Swift 5  サンプルコード delegateを利用するクラスとdelegateプロトコル  まずは、delegateを利用するMyClassクラスの定義とdelegateであるMyDelegateプロトコルの定義です MyClassのshow(text:)を呼ぶと、自身のプロパティとして保持するdelegateのonShowCalled(withText:)を呼ぶ実装となっています  class MyClass {  var delegate: MyDelegate?   func show(text: String) {  self.delegate?.onShowCalled(withText: text)  } }  protocol MyDelegate {  func onShowCalled(withText text: String) } delegateに準拠したクラス  delegateはプロトコルなので、利用する際にはそのプロトコルに準拠して内容を実装したクラスが必要です MyAdopted1とMyAdopted2の2つを用意し、それぞれ実装の異なるonShowCalled(withText:)を用意しています  class MyAdopted1: MyDelegate {  func onShowCalled(withText text: String) {  print(\u0026#34;MyAdopted1: \\(text)\u0026#34;)  } }  class MyAdopted2: MyDelegate {  func onShowCalled(withText text: String) {  print(\u0026#34;\\(text)from MyAdopted2!\u0026#34;)  } } delegateを指定  MyClassのインスタンスに、上記のMyAdopted1およびMyAdopted2をdelegateとして指定します MyClassのshow(text:)を呼ぶと、delegateとして指定したオブジェクトのonShowCalled(withText:)が実行されているのがわかります  let anObject1 = MyClass() anObject1.delegate = MyAdopted1() anObject1.show(text: \u0026#34;Hello\u0026#34;)  let anObject2 = MyClass() anObject2.delegate = MyAdopted2() anObject2.show(text: \u0026#34;Hello\u0026#34;) MyAdopted1: Hello Hello from MyAdopted2! まとめ  普段、プログラマは上記の「delegateに準拠したクラスの作成」と、「delegateを指定」部分を書くことが多いと思います delegateを利用するクラスを一度実装してみることで、delegateの仕組みについての理解が深まるのでおすすめです 今回作成したサンプルコードは、GitHubに置きました  aokiplayer/DelegateSample    "
},
{
	"uri": "https://yagamo-style.com/2019/06/21/assetfolder/",
	"title": "Asset Catalogで同じ名前の別画像を利用する",
	"tags": ["iOS", "Swift"],
	"description": "",
	"content": "はじめに  Xcodeのアセットカタログ（デフォルトではAssets.xcassets）は、画像などのリソースを管理します アセットカタログ内で、フォルダ分けも可能です その際、別のフォルダに同じ名前の画像を置きたくなることもあります その場合の扱い方です  検証環境  Xcode 10.2.1 iOS 12.2 Swift 5  フォルダにNamespaceを付与する デフォルトの状態（Namespaceなし）  この画像の例では、birdという画像がforestフォルダとseaフォルダの両方に配置されています ですが、デフォルトの状態ではフォルダ名は無視されるので、これらの画像にはbirdという名前でアクセスすることになり、区別ができません  フォルダ名付きでのアクセス（Namespaceあり）   アセットカタログ内でフォルダを選択し、Attributes InspectorからProvides Namespaceにチェックを入れると、そのフォルダ名がNamespaceとして利用されます\n フォルダの色も黄色から水色に変わっていますね    この画像の例では、それぞれforest/birdとsea/birdという名前で区別されます\n  こんな感じで、コード内でもInterface Builderでも参照できます\nimageView.image = index == 0 ? UIImage(named: \u0026#34;forest/bird\u0026#34;) : UIImage(named: \u0026#34;sea/bird\u0026#34;)   まとめ  Namespaceがあると、格段に管理がしやすくなりますね 今回作成したサンプルコードは、GitHubに置きました  aokiplayer/AssetFolderSample    参考  Asset Catalog Format Reference: Folders ios - Asset Catalog: Access images with same name in different folders - Stack Overflow  "
},
{
	"uri": "https://yagamo-style.com/2019/06/14/swiftuilist_beta/",
	"title": "SwiftUIで一覧表示画面を作成する",
	"tags": ["iOS", "Swift", "SwiftUI"],
	"description": "",
	"content": "はじめに  WWDC 2019で発表された目玉として、SwiftUIがあります 今回は、少しだけSwiftUIを触ってみたのでメモしてみます  検証環境  macOS 10.15 Catalina beta Xcode 11 beta iOS 13 beta Swift 5.1 iPad Pro 10.5 inch  ストーリーボードは？  これまで、レイアウトは基本的にストーリーボードで行ってきました ストーリーボードは決して悪いものではなく、まず画面の作成を始める際にはとても扱いやすいです ただし、ビューの数が増えたり、複雑なレイアウトをしようとすると非常に管理が難しいのも事実です  コードでレイアウトを行うSwiftUI  Flutterなどでは、画面をコード上で宣言的に記述できます 最近は、この形式をとるものが増えています SwiftUIも、コードから宣言的なレイアウトを行います これまでもコードのみで画面を作成できましたが、以下のような問題を抱えていました  プレビューの方法がないため、ビルドして実行しないと確認できない 手続的に記述するため、実際のレイアウトがイメージしにくい    SwiftUIで作成した一覧画面のサンプル 画面イメージ 実装ファイル  実装したのは、以下のファイルです     ファイル 説明     FoodModel.swift 表の1行分を表すデータモデル   FoodDataSource.swift 表示するデータを提供する   FoodRow.swift 表の各行を表すビュー。FoodListから利用される   FoodList.swift 表の全体を表すビュー。FoodDataSourceからデータを取得し、各行のFoodRowを生成する   ContentView.swift 最初に表示されるビュー。この中でFoodListを読み込む    FoodModel.swift import Foundation  struct FoodModel: Codable {  var id: Int  var title: String  var userName: String  var imageName: String  var liked: Bool = false } FoodDataSource.swift import Combine import SwiftUI  class FoodDataSource: BindableObject {  typealias PublisherType = PassthroughSubject   let didChange: FoodDataSource.PublisherType = PassthroughSubject\u0026lt;Void, Never\u0026gt;()  var foodData: [FoodModel]   init() {  foodData = [  FoodModel(id: 10, title: \u0026#34;スープカレー\u0026#34;, userName: \u0026#34;山田二郎\u0026#34;, imageName: \u0026#34;1\u0026#34;, liked: true),  FoodModel(id: 20, title: \u0026#34;そば屋のカレー\u0026#34;, userName: \u0026#34;川田吾郎\u0026#34;, imageName: \u0026#34;2\u0026#34;),  FoodModel(id: 30, title: \u0026#34;タイ風カレー\u0026#34;, userName: \u0026#34;里田舞\u0026#34;, imageName: \u0026#34;3\u0026#34;, liked: true),  FoodModel(id: 40, title: \u0026#34;スタミナジャンボカレー\u0026#34;, userName: \u0026#34;海田泳七郎\u0026#34;, imageName: \u0026#34;4\u0026#34;),  FoodModel(id: 50, title: \u0026#34;レッドカレー\u0026#34;, userName: \u0026#34;岡田八郎\u0026#34;, imageName: \u0026#34;5\u0026#34;)  ]   didChange.send(())  } } FoodRow.swift import SwiftUI  struct FoodRow : View {  var foodModel: FoodModel   var body: some View {  VStack(alignment: .leading) {  Image(foodModel.imageName)  .resizable()  .aspectRatio(contentMode: ContentMode.fit)  .shadow(radius: 10)  .border(Color.white, width: 2)   Text(foodModel.title).font(.headline)   HStack {  Text(foodModel.userName).font(.subheadline)  Spacer()  Image(foodModel.liked ? \u0026#34;liked\u0026#34; : \u0026#34;unliked\u0026#34;)  }  }.padding()  } }  #if DEBUG struct FoodRow_Previews : PreviewProvider {  static var previews: some View {  Group {  FoodRow(foodModel: FoodModel(id: 10, title: \u0026#34;Ramen\u0026#34;, userName: \u0026#34;Jiro Yamada\u0026#34;, imageName: \u0026#34;5\u0026#34;))  }.previewLayout(.fixed(width: 300, height: 400))  } } #endif FoodList.swift import SwiftUI  struct FoodList : View {  @ObjectBinding var foodDataSource = FoodDataSource()   var body: some View {  NavigationView {  List(foodDataSource.foodData.identified(by: \\.id)) { foodModel in  FoodRow(foodModel: foodModel)  }  .navigationBarTitle(Text(\u0026#34;Food list\u0026#34;))  }  } }  #if DEBUG struct FoodList_Previews : PreviewProvider {  static var previews: some View {  FoodList()  } } #endif ContentView.swift import SwiftUI  struct ContentView : View {  var body: some View {  FoodList()  } }  #if DEBUG struct ContentView_Previews : PreviewProvider {  static var previews: some View {  ContentView()  } } #endif まとめ よかった点  ちょっとした画面の作成であれば、SwiftUIはとても簡単に思えました macOS 10.15 Catalina上であれば、ライブビューでレイアウトだけでなく動作がすぐ確認できるのが良いです  難しく感じた点  ストーリーボードを利用していた際と、ビュー階層のイメージが異なるのでまだ戸惑っています また、思った通りにレイアウトができず苦労しています  サンプルプロジェクト  今回作成したサンプルコードは、GitHubに置きました  aokiplayer/SwiftUITableSample    参考  SwiftUI Tutorials | Apple Developer Documentation  "
},
{
	"uri": "https://yagamo-style.com/2019/05/26/seguecancel/",
	"title": "画面遷移（セグエ）のキャンセル",
	"tags": ["iOS", "Swift"],
	"description": "",
	"content": "はじめに  画面遷移のタイミングで条件を判断し、場合によってはキャンセルするような動作が必要な場面があります ボタンなどからAction接続したメソッド内でperformSegue(withIdentifier:sender:)を利用する場合や、addTarget(_:action:for:)でアクションを登録した場合であれば、その際に条件判断を行うこともできます  しかし、ボタンからセグエを直接引いて画面遷移する場合であれば、無条件に画面遷移してしまいます   ここでは、後者の場合に画面遷移の判断とキャンセルの方法について紹介します  検証環境  Xcode 10.2 iOS 12.2 Swift 5  利用するメソッド  UIViewControllerのshouldPerformSegue(withIdentifier:sender:)を利用します  このメソッドをオーバーライドします 動きとしては、trueを返した場合は画面遷移を実行、falseの場合はキャンセルとなります    サンプルプログラム 動作   NEXTボタンからセグエを引いてあり、スイッチがONの場合のみ画面遷移を行うプログラムです\n  サンプルコード import UIKit  class ViewController: UIViewController {   @IBOutlet weak var moveSwitch: UISwitch!   override func viewDidLoad() {  super.viewDidLoad()  }   override func shouldPerformSegue(withIdentifier identifier: String, sender: Any?) -\u0026gt; Bool {  super.shouldPerformSegue(withIdentifier: identifier, sender: sender)   // When the switch is off, it cancels the segue.  return moveSwitch.isOn  }   @IBAction func unwindToMain(_ unwindSegue: UIStoryboardSegue) {  } } まとめ  これを利用することで、「特定の状況下では画面遷移させない」が実現できます このサンプルでは利用していませんが、shouldPerformSegue(withIdentifier:sender:)の第1引数にはセグエのIdentifierが渡ってきます  この情報を利用することで、複数のセグエが引かれていた際、セグエごとに条件を個別に判断できますね   今回作成したサンプルは、GitHubに置きました  aokiplayer/SegueCancelSample    参考  shouldPerformSegue(withIdentifier:sender:) - UIViewController | Apple Developer Documentation  "
},
{
	"uri": "https://yagamo-style.com/2019/05/24/remotenotification02/",
	"title": "iOSにおけるPush通知の基本2（受信した通知の内容取得）",
	"tags": ["iOS", "Swift"],
	"description": "",
	"content": "はじめに  前の記事 [iOSにおけるPush通知の基本1（通知の受信まで）] では、以下のところまで紹介しました  Push通知に必要な事前設定 Push通知のユーザへの利用許可依頼 Push通知の送信テスト   これだけでも、受け取った通知をタップしてアプリを起動することができます 今回は、通知に含まれる内容（ペイロード）を取得する方法を説明します  検証環境  Xcode 10.2 iOS 12.2 Swift 5 iPod touch 6th generation  通知に対するコールバックメソッド   通知を受け取ると、UIApplicationDelegateの以下のコールバックメソッドが呼ばれます\n  呼ばれるコールバックメソッドとそのタイミングは、アプリの実行状態により決定されます\n   事前状態 タイミング メソッド     未起動 通知のタップにより起動 application(_:didFinishLaunchingWithOptions:)   Foreground 通知を受信 application(_:didReceiveRemoteNotification:fetchCompletionHandler:)   Background 通知のタップによりForeground application(_:didReceiveRemoteNotification:fetchCompletionHandler:)      これらのコールバック内で、通知のペイロード（通知に含まれるデータ）を取得して処理を行います\n  Push通知のペイロード   Push通知のペイロードは、以下のような形式のJSONです\n{  \u0026#34;aps\u0026#34; : {  \u0026#34;alert\u0026#34; : {  \u0026#34;title\u0026#34; : \u0026#34;New Message\u0026#34;,  \u0026#34;subtitle\u0026#34; : \u0026#34;You got a new message.\u0026#34;,  \u0026#34;body\u0026#34; : \u0026#34;New message has arrived. Open your inbox.\u0026#34;  },  \u0026#34;badge\u0026#34; : 3,  \u0026#34;sound\u0026#34; : \u0026#34;default\u0026#34;  } }   ペイロードの取得  受信したPush通知から、ペイロードを取り出す処理を実装します  そもそもどこから取り出すのか？  ペイロードは、UIApplicationDelegateのコールバックの引数に格納された状態で渡されます     コールバックメソッド 格納場所     application(_:didFinishLaunchingWithOptions:) 第2引数launchOptionsディクショナリ内   application(_:didReceiveRemoteNotification:fetchCompletionHandler:) 第2引数のuserInfoディクショナリ内    送信するPush通知の内容   今回は、以下の内容のPush通知を送ってみます\n{ \u0026#34;aps\u0026#34;: { \u0026#34;alert\u0026#34;: \u0026#34;Wake up!\u0026#34;, \u0026#34;sound\u0026#34;: \u0026#34;default\u0026#34; } }   実装例 アプリ未起動の場合  アプリが起動していない場合は通知をタップした時点でアプリが起動するので、ライフサイクルメソッドであるapplication(_:didFinishLaunchingWithOptions:)が呼ばれます このサンプルコードでは、ペイロードの内容を文字列として整形してビューコントローラのプロパティに渡しています  起動済みの場合と区別するために、背景色を黄色に設定しています    ペイロードの取得手順  第2引数のlaunchOptionsディクショナリからキーUIApplication.LaunchOptionsKey.remoteNotificationを指定  Push通知のペイロードを格納したディクショナリが得られる   Push通知のペイロードを格納したディクショナリから、キー\u0026quot;aps\u0026quot;でペイロードの内容部分のディクショナリを取得  func application(_ application: UIApplication,  didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool {   〜省略〜   // MARK:01. get notification payload  if let notificationOptions = launchOptions?[.remoteNotification] as? [String: AnyObject] {  guard let apsPart = notificationOptions[\u0026#34;aps\u0026#34;] as? [String: AnyObject] else { return true }   guard let vc = window?.rootViewController as? ViewController else { return true }  let text = apsPart.map { (key, value) in \u0026#34;\\(key): \\(value)\u0026#34; }.joined(separator: \u0026#34;\\n\u0026#34;)  vc.payloadText = text  vc.backgroundColor = .yellow  }   return true } 実行結果 アプリが起動中の場合  アプリが起動中の場合は、以下のタイミングでUIApplicationDelegateプロトコルのapplication(_:didReceiveRemoteNotification:fetchCompletionHandler:)が呼ばれます  アプリがForegroundの場合: 通知を受け取ったタイミング アプリがBackgroundの場合: 受け取った通知をタップしてForegroundになったタイミング   このサンプルコードでは、ペイロードの内容を文字列として整形してビューコントローラのプロパティに渡しています  未起動の場合と区別するために、背景色を緑に設定しています    ペイロードの取得手順  第2引数のuserInfoディクショナリからキー\u0026quot;aps\u0026quot;でペイロードの内容部分のディクショナリを取得 取得したディクショナリの扱いは、未起動の場合と同様    このコールバックを実装した場合、Backgorund ModesをONにすることを求められるので有効にしておきます\n エラーにはなりませんが、コンソールにメッセージが表示されます    func application(_ application: UIApplication,  didReceiveRemoteNotification userInfo: [AnyHashable : Any],  fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -\u0026gt; Void) {   // MARK:04. get notification payload  guard let apsPart = userInfo[\u0026#34;aps\u0026#34;] as? [String: AnyObject] else {  completionHandler(.failed)  return  }   guard let vc = window?.rootViewController as? ViewController else { return }  let text = apsPart.map { (key, value) in \u0026#34;\\(key): \\(value)\u0026#34; }.joined(separator: \u0026#34;\\n\u0026#34;)  vc.payloadText = text  vc.backgroundColor = .green  } 実行結果 まとめ  アプリの実行状態によって、呼ばれるコールバックが異なる点に注意 ペイロードはディクショナリから取り出す  受け取った時点で、すでにJSONからディクショナリに変換されている   今回作成したサンプルコードは、GitHubに置きました  aokiplayer/TreatPushNotificationPayloadSample    参考  UserNotifications | Apple Developer Documentation Push Notifications Tutorial: Getting Started | raywenderlich.com  "
},
{
	"uri": "https://yagamo-style.com/2019/05/21/viewcontrollerlifecycle/",
	"title": "UIViewControllerのライフサイクルメソッド",
	"tags": ["iOS", "Swift"],
	"description": "",
	"content": "はじめに  iOSアプリを作成していて、どのタイミングでどのメソッドが呼ばれるんだっけ？となることは多いです 特に、画面遷移の際に困ることがあります なので、非常に単純なサンプルを作成しておきました  各メソッド内で、コンソール出力をしているのみです    検証環境  Xcode 10.2 iOS 12.2 Swift 5  サンプルプロジェクト  aokiplayer/ViewControllerLifeCycleSample  サンプルの画面構成   画面はストーリーボードで作成しています\n  A, Bの2画面があり、以下のように遷移します（Aが初期画面）\n A -\u0026gt; Bは、単純にPresent Modallyなセグエで遷移 B -\u0026gt; Aは、unwindセグエで遷移    コンソール出力例 アプリ起動（Aを表示）  レイアウト系が2度呼ばれています  レイアウトは、様々なタイミングで呼ばれるのでこのように複数回呼ばれる可能性があるためです  boundsが変更されたり、サブビューが追加されたりしても呼ばれます   Auto Layoutの制約を明示的に設定せず、Autoresizing maskをAuto Layoutに変換した場合などは1度しか呼ばれなかったりします    A: init(coder:) A: loadView() A: viewDidLoad() A: viewWillAppear(_:) A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() A: viewDidAppear(_:) 画面を回転（A画面表示中）  レイアウトを組み直す必要が発生するので、こんな感じですね  A: viewWillTransition(to:with:) A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() HOMEボタンを押す（A画面表示中）  画面は表示されなくなりますが、実際にはいずれのコールバックも呼ばれていません  このあたりの挙動は、Androidとは異なりますね（Androidではこのタイミングでもコールバック呼ばれる）    HOME画面でアイコンをタップ（上記の操作後）  非表示状態からの復帰ですが、いずれのコールバックも呼ばれていません  これも、Androidの場合はコールバックが呼ばれますね    Bへ遷移（Present Modallyセグエ）  ポイントはAのprepare(for:sender:)のタイミングです  ここで必要なデータの受け渡しを行いますが、BのviewDidLoad()よりも前です そのため、この時点ではBの持っているビューはnilであり、データを渡そうとすると実行時エラーとなります     B: init(coder:) A: prepare(for:sender:)  B: loadView()  B: viewDidLoad() A: viewWillDisappear(_:)  B: viewWillAppear(_:)  B: viewWillLayoutSubviews()  B: viewDidLayoutSubviews() A: viewWillLayoutSubviews() A: viewDidLayoutSubviews()  B: viewWillLayoutSubviews()  B: viewDidLayoutSubviews()  B: viewDidAppear(_:) A: viewDidDisappear(_:) Aへ戻る（unwindセグエ）  unwindセグエで戻る際も、prepare(for:sender:)は呼ばれています   B: prepare(for:sender:) A: unwindToFirst(_:)  B: viewWillDisappear(_:) A: viewWillAppear(_:) A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() A: viewDidAppear(_:)  B: viewDidDisappear(_:)  B: deinit A: viewWillLayoutSubviews() A: viewDidLayoutSubviews() まとめ  初心者の陥りやすい点としては、prepare(for:sender:)内でのデータの受け渡しです 「遷移先画面のビューはまだnil」という点は、しっかり認識しておきましょう  "
},
{
	"uri": "https://yagamo-style.com/2019/04/18/remotenotification01/",
	"title": "iOSにおけるPush通知の基本1（通知の受信まで）",
	"tags": ["iOS", "Swift"],
	"description": "",
	"content": "はじめに  Push通知は、使い方によっては非常に効果的です  通知しすぎると、邪魔になってしまいますが   ここでは、Push通知の基本的な実装方法を説明します Push通知の実装には、UserNotificationsフレームワークを利用します  ローカル通知にも、同じフレームワークを利用します 昔と違って、ひとつのフレームワークで両方に対応できていいですね    検証環境  Xcode 10.2 iOS 12.2 Swift 5 iPod touch 6th generation  必要なもの  Apple Developer Programのアカウント  Apple Developerサイト上で、以下の確認・作成が必要なため  Team ID Authentication Key     APNs（Apple Push Notification Service）に対応した、Push通知を送信するサーバ  FirebaseとかMicrosoft Azureとか、いろいろなサービスが対応してます テストするだけなら、APNsに対応したいろいろなツールがあります  Dwarven/PushMeBaby onmyway133/PushNotifications   APNsは、その名のとおりAppleのPush通知サービスです  Push通知の送信は、必ずこのサービスを経由します     iPhoneやiPadなどの実デバイス   シミュレータではPush通知が利用できないため\n  シミュレータでPush通知の登録をしようとすると、コンソールに以下のようなメッセージが出力されます\nFailed to register: Error Domain=NSCocoaErrorDomain Code=3010 \u0026#34;remote notifications are not supported in the simulator\u0026#34; UserInfo={NSLocalizedDescription=remote notifications are not supported in the simulator}     事前準備（Apple Developerサイト上） Team IDの確認   Apple Developerサイトにログイン\n  左側のMembershipを選択して、Membership Detailsに表示されたTeam IDをメモしておく\n  Authentication Keyの作成とダウンロード   Apple Developerサイトにログイン\n  左側のCertificates, IDs \u0026amp; Profilesを選択\n  表示された画面で左側のKeysからAllを選択、右上の+をクリックしてキーを作成\n Nameには、キーに設定する任意の名前を入力 Apple Push Notification service (APNs)にチェック    作成したら、Downloadをクリックしてキーをダウンロード\n キーは一度しかダウンロードできません。セキュアな場所に確実に保存してください このキーは、Push通知を行うサーバに設定する キーは、AuthKey_XXXXXXXXXX.p8という名前でダウンロードされる XXXXXXXXXXの部分がKey ID Key IDもメモしておく    主なコンポーネント    コンポーネント 説明     UNUserNotificationCenter 通知関連の機能を管理する   UNNotificationRequest 通知の内容や、配送のトリガーを内包する   UNNotificationAction 通知内で表示されるボタン   UNNotificationCategory 通知の方法や表示されるアクションの設定をまとめたもの   UNNotificationSettings 通知の設定情報を保持   UNMutableNotificationContent 通知する内容   UNPushNotificationTrigger APNsから送信された通知に関するトリガー    実装手順 プロジェクトの設定   アプリケーションTARGETのSigningから、Teamを選択\n Apple Developer Programに登録済みのアカウントに紐付いている必要性あり 無料アカウントのTeamでは、Push Notificationが利用できない    アプリケーションTARGETのCapabilitiesから、Push NotificationsをONにする\n  プッシュ通知の登録  ここから先は、すべてAppDelegate.swift内に記述します  アプリの起動時に処理するのと、UIApplicationDelegateのコールバックが必要になるためです      UserNotificationsフレームワークを利用するので、インポート\nimport UserNotifications // MARK:01. import   ユーザに対して、通知の許可依頼を行う\nfunc application(_ application: UIApplication,  didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool {   // MARK:02. request to user  UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in  guard granted else { return }   // 〜省略〜  }  return true }   ユーザが通知を許可していた場合は、APNsへ登録\n  **「どのデバイスにインストールされたどのアプリか」**を登録する\n  これにより、APNsは対象を特定して通知を発行できるようになる\n  この結果として、一意に識別するトークンが返される\n// MARK:02. request to user UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in  guard granted else { return }   // MARK:03. register to APNs  DispatchQueue.main.async {  UIApplication.shared.registerForRemoteNotifications()  } }     APNsへの登録後に呼び出されるコールバックを実装（UIApplicationDelegateのメソッド）\n 成功時: application(_:didRegisterForRemoteNotificationsWithDeviceToken:)  先述したトークンは第2引数に渡される このトークンを、Push通知を送信するサービスに登録する必要がある  今回はテストとしてmacOS上のプログラムからPush通知を送信するので、トークンをログ出力しておく 外部のサービスへトークンを登録する方法は、各サービスのドキュメントを参照してください     失敗時: application(_:didFailToRegisterForRemoteNotificationsWithError:)  // MARK:- Callback for Remote Notification extension AppDelegate {  // MARK:04-1. succeeded to register to APNs  func application(_ application: UIApplication,  didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {  // Data -\u0026gt; Token string  let tokenBytes = deviceToken.map { (byte: UInt8) in String(format: \u0026#34;%02.2hhx\u0026#34;, byte) }  print(\u0026#34;Device token: \\(tokenBytes.joined())\u0026#34;)  }   // MARK:failed to register to APNs  func application(_ application: UIApplication,  didFailToRegisterForRemoteNotificationsWithError error: Error) {  print(\u0026#34;Failed to register to APNs: \\(error)\u0026#34;)  } }   アプリを一度実行して通知の受信を許可し、前の手順でログ出力したトークンをメモしておきます\n もちろん、実運用上はこの手順は不要です 実際には、application(_:didRegisterForRemoteNotificationsWithDeviceToken:)内で外部サービスにトークンを登録する処理が必要になります  Device token: b92bf1a8af26237ad8dfad91312ece9563c8493e2bc2bf01e3bd9fb690d20d37   ここまでの実装（AppDelegate.swift） import UIKit import UserNotifications // MARK:01. import  @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate {   var window: UIWindow?   func application(_ application: UIApplication,  didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool {   // MARK:02. request to user  UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in  guard granted else { return }   // MARK:03. register to APNs  DispatchQueue.main.async {  UIApplication.shared.registerForRemoteNotifications()  }  }  return true  } }  // MARK:- Callback for Remote Notification extension AppDelegate {  // MARK:04-1. succeeded to register to APNs  func application(_ application: UIApplication,  didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {  // Data -\u0026gt; Token string  let tokenBytes = deviceToken.map { (byte: UInt8) in String(format: \u0026#34;%02.2hhx\u0026#34;, byte) }  print(\u0026#34;Device token: \\(tokenBytes.joined())\u0026#34;)  }   // MARK:failed to register to APNs  func application(_ application: UIApplication,  didFailToRegisterForRemoteNotificationsWithError error: Error) {  print(\u0026#34;Failed to register to APNs: \\(error)\u0026#34;)  } } Push通知の受信テスト  Push通知が受信できることをテストしてみます 今回はonmyway133/PushNotificationsを利用するので、インストールしておいてください    Push通知の送信準備（PushNotificationsアプリ）\n  iOSを選択\n  Authentication -\u0026gt; TOKEN\n   項目 設定値     SELECT P8 ダウンロードしておいたAuthentication Keyを選択   Enter key id メモしておいたKey IDを入力   Enter team id メモしておいたTeam IDを入力      Body\n   項目 設定値     Enter bundle id アプリのBundle Identifierを入力   Enter device token メモしておいたトークンを入力   Enter message Push通知のメッセージとなるJSONを入力    { \u0026#34;aps\u0026#34;: { \u0026#34;alert\u0026#34;: \u0026#34;Minimal message\u0026#34;, \u0026#34;sound\u0026#34;: \u0026#34;default\u0026#34; } }   Environment\n Sandboxにチェック      Push通知の送信\n Sendボタンをクリックすると、Push通知が送信されます    Push通知の受信確認\n 通知は、アプリが表示されていない状態（以下の状態）で受信した場合に表示されます  アプリが起動していて、Backgroud状態 アプリが起動していない      まとめ  単純にPush通知を受信して、アプリを開くだけならこれだけの実装で済みます また、以下のような実装も可能です  通知にボタン（アクション）を追加して、タップした際に処理を実行する アプリが起動していない状態でも、アプリを起こしてタスクをバックグラウンドで実行させる   通知にはUserNotificationsフレームワークを利用するので、以下の点を除いてローカル通知もほぼ同様の実装で受信できます  APNsへの登録がない（デバイスの中で完結するため） 通知を送信する処理の実装が必要   今回作成したサンプルコードは、GitHubに置きました  aokiplayer/MinimalRemoteNotificationSample    参考  UserNotifications | Apple Developer Documentation Push Notifications Tutorial: Getting Started | raywenderlich.com  "
},
{
	"uri": "https://yagamo-style.com/categories/report/",
	"title": "Report",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/tags/try-swift/",
	"title": "try! Swift",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://yagamo-style.com/2019/04/17/tryswifttokyo2019/",
	"title": "try! Swift Tokyo 2019 感想など",
	"tags": ["try! Swift", "iOS", "Swift"],
	"description": "",
	"content": "try! Swift Tokyo 2019 に参加してきました。 今年も会社のブースにいたのでセッション自体はあまり聞くことができませんでしたが、得るものはたくさんありました。\nだいぶ時間が経ってしまったけど、感想を少し書いてみます。\n公式サイト、ハッシュタグなど  https://www.tryswift.co/events/2019/tokyo/jp/ @tryswiftconf #tryswiftconf  ここが良かった スポンサーとして 知名度が少し上がってきた  Java 系ではそれなりに知名度がある弊社ですが、モバイル系のカンファレンスに継続して参加することでこちらでも知名度が少しずつ上がってきました。 いろいろな方から、声を掛けて頂けました。  商品をお見せするのが大事  今回はマーケティングチームのアイディアで、主に私の執筆したトレーニングテキストのサンプルを展示しました。 実際に手に取ってご覧頂くことで、以下の効果が得られました。  弊社の業務やトレーニング内容をイメージ頂けた -\u0026gt; 参加者の皆様との会話のきっかけとなった たくさんのご意見を頂けた  「市販書籍よりもわかりやすい」「ここに書いてるのよりも、こっちのライブラリを使ったほうがいい」 「テキストを売って欲しい」「現場に出る前の教育に使いたい」      エンジニアとして 世界的なエンジニアに直接聞ける  私は IBM Kitura を使い始めているのですが、せっかく Kitura の開発チームが来日されていたので、うまくいかない点を思い切って質問してみました。  その上で、Kituraのドキュメント自体に誤りがあることなどを発見できました。 \u0026lt;- 貢献できた！   セッション自体はあとで動画がアップロードされますが、質問はその場でしかできないので、貴重な経験でした。 英語は、できなくてもこわくないです（もちろん、できた方がいいけど）。  言いたいことがはっきりしていれば、文法を多少誤っていたり単語が出てこなかったりしても伝わります。 カンファレンス前日の Global Communication Workshop for try! Swift で、背中を押してもらえた気がします。    今後に向けて  個人・企業ともスポンサーは続けていきたいです。 参加して良かった！で終わらせない。今は IBM Kitura ブースで頂いた本（抽選に当たりました）も使いながら Kitura を学習してます。  "
},
{
	"uri": "https://yagamo-style.com/2018/09/15/iosdc2018/",
	"title": "iOSDC 2018 感想など",
	"tags": ["iOSDC", "iOS", "Swift"],
	"description": "",
	"content": "今年も個人サポーター（初回から 3 年連続）として iOSDC に参加してきました。トークには応募してたけど、残念ながら選に漏れました。 あと、弊社は昨年からブーススポンサーをやってるので、そっちにも顔を出してました。\n公式サイト、ハッシュタグなど  https://iosdc.jp/2018/ @iosdcjp #iosdc iOSDC 2018 セッション資料まとめ  今年は 8/30-9/2 の開催でしたが、 8/30-31 は残念ながら iOSDE に登壇していたので iOSDC には 9/1,2 のみ参加です（名前が紛らわしい）。\nセッションは高度な内容から日常で使える tips 、入門者向けの内容まで幅広く、どのレベルのエンジニアでも学びの得られる門戸の広いカンファレンスでした。特に後者はカンファレンスでは蔑ろにされることが多い気がするけど、いろんなエンジニアが学べて交流できるのって大事だなと思ってます（なので来年もそっち系でトーク応募します）。\nここがよかった 参加者として  初回からずっと参加してますが、「ここがもうちょっとこうなってるといいな」が毎年着実に改善されています。 昨年導入された「パックマンルール」もすごい！って思ったけど、今年の「機械的席詰めタイム」はそれ以上によく考えられてるなと思いました。 みんな気持ち的には「詰めた方がいいんだろうな」と思いつつ、最初から詰めるのは何となく気が引ける。で、結果的に 3 人掛けだと真ん中が空いちゃって後から来る人が入りづらい。それを上手く解決してるなーととても感心しました。 ノベルティのサコッシュ（斜め掛けのバッグ）。スリーブに入れた MacBook と iPad Pro 10.5 インチがぴったり収まるし、トートバッグと違って両手が空くのでとても便利でした。カンファレンス中、大活躍でした。 バドワイザー（瓶）が今年も継続されてた。  スポンサー＆サポーターとして  昨年ブーススポンサー用に作成して頂いた各社ロゴの缶バッジは、参加者がブースを回るモチベーションとなりとても好評でした（あと、登壇者に目立つところに付けて頂くことで露出を狙えた）。 今年はそういう感じのはないのか…とちょっとだけ残念な気持ちでしたが、運営の方々の思いである「参加者も一緒にイベントを作っていく仲間」というのが 3 年目ともなるとしっかり浸透していて、結果的に多くの方々に立ち寄って頂けました。 昨年は個人サポーター（個人スポンサー）の T シャツが一般と同じだったので、パーカーを着てないと見分けがつかなかったけど今年は一般がシルバー、個人サポーターがゴールドと違いがあってうれしかった（でもスポンサーブース用に会社のポロシャツを着てたので、着るチャンスがなかった…）。 来年もやります。  あれ？と思った点  昨年は LT の投票＆賞ってレギュラートークとは別にありませんでしたっけ？（うろ覚え）   参加したトークのひとこと感想 9/1 詳解 Fastfile  スピーカー: ぎぎにゃん さん @giginet 「詳解 Fastlane だと勘違いしてた人が…」あっ、はい Fastfile の話でしたが、以下のように Fastlane に限らず一般的に有用な内容でした  値は環境変数から読み込む 設定とロジックを分ける   私自身は Fastlane を使い始めたばかりなので、実際にこの辺りを見ながら少しずつ適用していきたいです  Depth in Depth  スピーカー: 堤修一 さん @shu223 深度はボケのためだけではない、という話でした 深度の種類やセンサーの仕組みなどから、丁寧に説明されていました 私自身は、深度を可視化するアプリを利用してていつも面白いなーと思ってましたが、意外と取るのは単純だと感じました（でもやったら多分難しいとは思う） 説明の明快さもさることながら、人物をくり抜いて背景合成するというキャッチーなデモが非常に分かり易かったです この日に生まれたお子さんが、私の娘と同じ誕生日なので何となくうれしいです。おめでとうございます！  5000 行の UITableView を差分更新する  スピーカー: ばんじゅん さん @banjun 差分更新のライブラリ比較や、パフォーマンスを落とさないための試行錯誤などに関する内容でした UITableView の差分更新については、 8/30, 31 にもいくつかセッションがあったようです ライブラリを入れればそれで解決、とは行かないようでした 実際にパフォーマンスが上がらずに、そのボトルネックを突き止め改善するプロセス自体が有用でした  気遣いの iOS プログラミング  スピーカー: ezura さん @eduraaa どの場面でも利用すべきベストなものはなく、いろいろな場面に活用できる引き出しを増やすことが重要というお話でした いくつか具体例を出しながら、コードの意図をより伝えやすい記述を紹介していました 紹介されていたどれも、 Swift らしい言語機能を上手く活用していました そのため、むしろ Java などの言語から移ってきた人にはすぐには理解しがたいのかもしれないと感じました メンバーの習熟度も考慮して採用する記述方法を記述する必要があり、引き出しを増やしておくのは重要だと思います   9/2 iOS マイクロインタラクション入門  スピーカー: kiwi さん @koga_wiwi 「マイクロインタラクション = ちょっとした相互作用」を活用することで、操作の心地良さにつながるという話でした いくつか、具体的な実装方法も紹介しながらのセッションでした 機能要件的には不要であるものの、特にコンシュマー向けのアプリでは UX が重要ですよね 本のちょっとしたことでも、全く印象は変わるので少しずつ試してみたいです  プロトコルを使って複数サービスを跨いだ music player を実装する  スピーカー: kumabook さん @kumabook 実際に開発した、複数の音楽サービスをサポートするアプリ開発時の知見でした Apple Music の曲の後に Spotify の曲、その後に SoundCloud の…といったような再生が可能となっているそうです それぞれのサービスごとに利用する API の形式は違うので、プロトコルを活用して共通化されていました サービスによってサポートされていない機能などもある中で、できる限り共通化するための試行錯誤があったようです ただ、「再生する」「停止する」などの根幹部分はある程度近いので、その辺りを中心に考えると設計がしやすそうでした  Auto Layout エラー診断所  スピーカー: akatsuki174 さん @akatsuki174 Auto Layout 利用時に発生するエラーや警告を解消するためのデバッグ手法を、具体例とともに紹介するセッションでした また、その際に役立つツールなどの紹介もあり、 Auto Layout を利用している場合はすぐに役立つ構成となっていました Auto Layout については、初学者のみならず苦戦すると思います このセッションの内容はまさに「明日からすぐ使える」ものなので、ぜひ取り入れていきたいです  教育・企業におけるデバイス管理手法について  スピーカー: 大西正恭 さん @kenchan0130 組織内における Apple デバイスの管理について、概要が全体的に整理されていました なぜ必要なのか、何ができるのか、何が必要なのかが整理されたセッションでした 私自身は Apple 認定 iOS Deployment Essentials で教えているので、内容はだいたいわかってました ただ、具体的な MDM 製品を導入して管理している立場の方のご意見を伺いたくて参加しました デベロッパーには意外とデバイス管理は知られていないので、こういう内容のが増えるといいなと思います  iOS でグラフを描くために必要な知識について  スピーカー: 須藤将史 さん @kurotyann9696 数学的な円の基礎知識の復習から、段階を追いながら円グラフを書いていく内容でした 「こんな風になってるといいよね」から「それを実現するためには」を明確に示しながら、理解を深める説明がなされていました 私自身は現状、「なんとなく難しそう」という理由でアプリ内でグラフなどは使っていませんが、このセッションを聞いて気持ちが変わりました 説明が非常に明快で、グラフの書き方以上にワクワク感が伝わってきました やはり情報を伝えるためには文字情報よりも、グラフや図解が圧倒的に有効だというのを再認識しました  "
}]