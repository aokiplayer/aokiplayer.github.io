<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SwiftUI on Yagamo Style</title>
    <link>https://yagamo-style.com/tags/swiftui/</link>
    <description>Recent content in SwiftUI on Yagamo Style</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Mon, 04 Dec 2023 06:00:00 +0900</lastBuildDate><atom:link href="https://yagamo-style.com/tags/swiftui/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SwiftUI の dismiss() って「関数()」じゃなくて「オブジェクト()」だよね？</title>
      <link>https://yagamo-style.com/2023/12/04/call-as-function/</link>
      <pubDate>Mon, 04 Dec 2023 06:00:00 +0900</pubDate>
      
      <guid>https://yagamo-style.com/2023/12/04/call-as-function/</guid>
      <description>はじめに SwiftUI で多用されている Property Wrappers ですが、基本的に「なんか難しいことをやってくれてる」感じになってます。頻繁に利用される @Environment も、「こう書けばこう動く」という感じで何となく使っている人が多いと思います。
ところで、Property Wrapper そのものの機能とは関係ないですが、以下のコードの @Environment の dismiss() の部分はよく考えると不思議な構文ではないでしょうか。
// ビューを閉じるための DismissAction を取得 @Environment(\.dismiss) private var dismiss: DismissAction  ...  // ビューを閉じる dismiss() // &amp;lt;--- オブジェクト() という構文？？？ dismiss は DismissAction 型のオブジェクトなので、本来なら以下の形式でないと辻褄が合いませんよね。
dismiss.何かメソッド名() // &amp;lt;--- オブジェクト.メソッド名() という構文ならわかる 検証環境  Xcode 15.0 Swift 5.9  callAsFunction メソッド 実は、これは dismiss.何かメソッド名() の省略形です。 具体的には dismiss.callAsFunction() です。
callAsFunction の例 例として、単に「足し算をするためだけの構造体」を用意し、callAsFunction メソッドを実装して利用してみます。
import Foundation // 足し算をするためだけの構造体 struct AddAction { public func callAsFunction(_ number1: Int, with number2: Int) -&amp;gt; Int { return number1 + number2 } } let add = AddAction() // 以下は add.</description>
    </item>
    
    <item>
      <title>SwiftUI でサイズクラスに対応する</title>
      <link>https://yagamo-style.com/2022/12/12/sizeclass-swiftui/</link>
      <pubDate>Mon, 12 Dec 2022 06:00:00 +0900</pubDate>
      
      <guid>https://yagamo-style.com/2022/12/12/sizeclass-swiftui/</guid>
      <description>はじめに Storyboard を利用していると、サイズクラスを利用して以下のように柔軟にビューのレイアウトを変更することが、比較的簡単に実現できていました。
 iPad で画面を分割していないので、幅が十分にあるからビューを横に並べよう iPad をマルチタスキングで画面分割して幅が狭くなったので、ビューを縦に並べよう  UIStackView で、幅と高さが Regular のデバイス（iPad で画面非分割時など）の場合のみサブビューを横に並べるのであれば、以下のような設定を行いました。
サイズクラスは SwiftUI でも利用できるので、その使い方を記載します。
今回のゴール 以下のように、画面幅の広い状態ではビューを横に、狭い状態では縦に並べるように設定します。
   w:Regular w:Compact          検証環境  macOS Ventura 13.0.1 Xcode 14.1 iOS/iPadOS 16.1  サイズクラスとは サイズクラスは、その名のとおり「デバイスのサイズを分類する」概念です。サイズクラスでは、ざっくりとデバイスの縦横を「普通（Regular）」「小さい（Compact）」の組み合わせで表します。 それにより、最大で 4 通りの画面サイズ（w: Regular x h: Regular, &amp;hellip;, w: Compact x h: Compact）にデバイスを分類してビューのレイアウトを行います。 サイズクラスを使うことで、全部のデバイスに個々に対応せず、大まかな分類ごとにレイアウトを行えば済むので労力が削減できます。
4 パターン全部に対応せずとも、iPad の画面分割のことを考えるのであれば、幅のみに着目して 2 パターンでレイアウトすることが多いのではないでしょうか。
サイズクラス情報の取得 現在表示中のビューがどのサイズクラスなのかは、Environment から列挙型 UserInterfaceSizeClass 型の値として取得できます。
@Environment(\.horizontalSizeClass) private var horizontalSizeClass @Environment(\.</description>
    </item>
    
    <item>
      <title>Swift の型消去（Type Erasure）</title>
      <link>https://yagamo-style.com/2022/10/26/type-erasure/</link>
      <pubDate>Wed, 26 Oct 2022 14:03:56 +0900</pubDate>
      
      <guid>https://yagamo-style.com/2022/10/26/type-erasure/</guid>
      <description>はじめに SwiftUI をしっかり理解しようとすると、これまで意識しなくて良かった多くの言語機能を知る必要があり、なかなか苦労します。 その 1 つとして、型消去（Type Erasure）があります。 ずっとわかったようなわからないような感じだったので、腰を据えて調べてみました。 まだこれについては自信がないので、ご指摘などあれば GitHub から頂けるとうれしいです。
サンプルは GitHub に置きました。
前提: プロトコルに関する制約事項 Swift では、associatedtype を持つプロトコルは、型宣言に利用できません。 以下のコードでは、最下部で Store 型の変数を宣言しようとしていますが、コンパイルが通りません。 これは、Store の持つ associatedtype の型が確定しないためです。
// お店で扱う商品の種類 struct Drug {  var item: String }  /** 何らかのお店を表すプロトコル. 商品の種類は associatedtype により柔軟に指定できるようにしている. */ protocol Store {  associatedtype T   var kind: T { get }  func kindsOfStore() -&amp;gt; T }  /** 具体的なお店（マツモトキヨシ）. associatedtype は Drug として確定. */ class MatsumotoKiyoshi: Store {  var kind: Drug   init(kind: Drug) {  self.</description>
    </item>
    
    <item>
      <title>SwiftUI のモディファイアの順序による結果の相違</title>
      <link>https://yagamo-style.com/2022/10/14/swiftui-modifier-order/</link>
      <pubDate>Fri, 14 Oct 2022 10:17:36 +0900</pubDate>
      
      <guid>https://yagamo-style.com/2022/10/14/swiftui-modifier-order/</guid>
      <description>はじめに SwiftUI は、ビューに対してモディファイアをメソッドチェーン形式で追加していくという統一的な操作ができるので、とてもわかりやすいですよね。 時にはモディファイアが多すぎて、見通しが悪くなることはありますが…。
簡単に扱えるモディファイアですが、順序には注意する必要があります。
検証環境  macOS Monterey 12.6 Xcode 14.0.0  実験 Text に、frame(), padding(), border() の 3 つのモディファイアを設定してみます。 設定順序の組み合わせは 3! 通りあります。
サンプルコード それぞれ、枠線を付けた同じサイズの VStack 内に上記 3 つのモディファイアの順序を変えた Text を配置しています。
import SwiftUI  struct ContentView: View {  var body: some View {  VStack {  Text(&amp;#34;モディファイアの順序&amp;#34;)  .font(.title)   VStack {  Text(&amp;#34;frame -&amp;gt; border -&amp;gt; padding&amp;#34;)  .frame(width: 300, height: 60)  .border(.red, width: 3)  .</description>
    </item>
    
    <item>
      <title>SwiftUIで一覧表示画面を作成する</title>
      <link>https://yagamo-style.com/2019/06/14/swiftuilist_beta/</link>
      <pubDate>Fri, 14 Jun 2019 13:16:59 +0900</pubDate>
      
      <guid>https://yagamo-style.com/2019/06/14/swiftuilist_beta/</guid>
      <description>はじめに  WWDC 2019で発表された目玉として、SwiftUIがあります 今回は、少しだけSwiftUIを触ってみたのでメモしてみます  検証環境  macOS 10.15 Catalina beta Xcode 11 beta iOS 13 beta Swift 5.1 iPad Pro 10.5 inch  ストーリーボードは？  これまで、レイアウトは基本的にストーリーボードで行ってきました ストーリーボードは決して悪いものではなく、まず画面の作成を始める際にはとても扱いやすいです ただし、ビューの数が増えたり、複雑なレイアウトをしようとすると非常に管理が難しいのも事実です  コードでレイアウトを行うSwiftUI  Flutterなどでは、画面をコード上で宣言的に記述できます 最近は、この形式をとるものが増えています SwiftUIも、コードから宣言的なレイアウトを行います これまでもコードのみで画面を作成できましたが、以下のような問題を抱えていました  プレビューの方法がないため、ビルドして実行しないと確認できない 手続的に記述するため、実際のレイアウトがイメージしにくい    SwiftUIで作成した一覧画面のサンプル 画面イメージ 実装ファイル  実装したのは、以下のファイルです     ファイル 説明     FoodModel.swift 表の1行分を表すデータモデル   FoodDataSource.swift 表示するデータを提供する   FoodRow.swift 表の各行を表すビュー。FoodListから利用される   FoodList.</description>
    </item>
    
  </channel>
</rss>
