<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SwiftUI on Yagamo Style</title>
    <link>https://yagamo-style.com/tags/swiftui/</link>
    <description>Recent content in SwiftUI on Yagamo Style</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Wed, 26 Oct 2022 14:03:56 +0900</lastBuildDate><atom:link href="https://yagamo-style.com/tags/swiftui/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Swift の型消去（Type Erasure）</title>
      <link>https://yagamo-style.com/2022/10/26/type-erasure/</link>
      <pubDate>Wed, 26 Oct 2022 14:03:56 +0900</pubDate>
      
      <guid>https://yagamo-style.com/2022/10/26/type-erasure/</guid>
      <description>はじめに SwiftUI をしっかり理解しようとすると、これまで意識しなくて良かった多くの言語機能を知る必要があり、なかなか苦労します。 その 1 つとして、型消去（Type Erasure）があります。 ずっとわかったようなわからないような感じだったので、腰を据えて調べてみました。 まだこれについては自信がないので、ご指摘などあれば GitHub から頂けるとうれしいです。
サンプルは GitHub に置きました。
前提: プロトコルに関する制約事項 Swift では、associatedtype を持つプロトコルは、型宣言に利用できません。 以下のコードでは、最下部で Store 型の変数を宣言しようとしていますが、コンパイルが通りません。 これは、Store の持つ associatedtype の型が確定しないためです。
// お店で扱う商品の種類 struct Drug {  var item: String }  /** 何らかのお店を表すプロトコル. 商品の種類は associatedtype により柔軟に指定できるようにしている. */ protocol Store {  associatedtype T   var kind: T { get }  func kindsOfStore() -&amp;gt; T }  /** 具体的なお店（マツモトキヨシ）. associatedtype は Drug として確定. */ class MatsumotoKiyoshi: Store {  var kind: Drug   init(kind: Drug) {  self.</description>
    </item>
    
    <item>
      <title>SwiftUI のモディファイアの順序による結果の相違</title>
      <link>https://yagamo-style.com/2022/10/14/swiftui-modifier-order/</link>
      <pubDate>Fri, 14 Oct 2022 10:17:36 +0900</pubDate>
      
      <guid>https://yagamo-style.com/2022/10/14/swiftui-modifier-order/</guid>
      <description>はじめに SwiftUI は、ビューに対してモディファイアをメソッドチェーン形式で追加していくという統一的な操作ができるので、とてもわかりやすいですよね。 時にはモディファイアが多すぎて、見通しが悪くなることはありますが…。
簡単に扱えるモディファイアですが、順序には注意する必要があります。
検証環境  macOS Monterey 12.6 Xcode 14.0.0  実験 Text に、frame(), padding(), border() の 3 つのモディファイアを設定してみます。 設定順序の組み合わせは 3! 通りあります。
サンプルコード それぞれ、枠線を付けた同じサイズの VStack 内に上記 3 つのモディファイアの順序を変えた Text を配置しています。
import SwiftUI  struct ContentView: View {  var body: some View {  VStack {  Text(&amp;#34;モディファイアの順序&amp;#34;)  .font(.title)   VStack {  Text(&amp;#34;frame -&amp;gt; border -&amp;gt; padding&amp;#34;)  .frame(width: 300, height: 60)  .border(.red, width: 3)  .</description>
    </item>
    
    <item>
      <title>SwiftUIで一覧表示画面を作成する</title>
      <link>https://yagamo-style.com/2019/06/14/swiftuilist_beta/</link>
      <pubDate>Fri, 14 Jun 2019 13:16:59 +0900</pubDate>
      
      <guid>https://yagamo-style.com/2019/06/14/swiftuilist_beta/</guid>
      <description>はじめに  WWDC 2019で発表された目玉として、SwiftUIがあります 今回は、少しだけSwiftUIを触ってみたのでメモしてみます  検証環境  macOS 10.15 Catalina beta Xcode 11 beta iOS 13 beta Swift 5.1 iPad Pro 10.5 inch  ストーリーボードは？  これまで、レイアウトは基本的にストーリーボードで行ってきました ストーリーボードは決して悪いものではなく、まず画面の作成を始める際にはとても扱いやすいです ただし、ビューの数が増えたり、複雑なレイアウトをしようとすると非常に管理が難しいのも事実です  コードでレイアウトを行うSwiftUI  Flutterなどでは、画面をコード上で宣言的に記述できます 最近は、この形式をとるものが増えています SwiftUIも、コードから宣言的なレイアウトを行います これまでもコードのみで画面を作成できましたが、以下のような問題を抱えていました  プレビューの方法がないため、ビルドして実行しないと確認できない 手続的に記述するため、実際のレイアウトがイメージしにくい    SwiftUIで作成した一覧画面のサンプル 画面イメージ 実装ファイル  実装したのは、以下のファイルです     ファイル 説明     FoodModel.swift 表の1行分を表すデータモデル   FoodDataSource.swift 表示するデータを提供する   FoodRow.swift 表の各行を表すビュー。FoodListから利用される   FoodList.</description>
    </item>
    
  </channel>
</rss>
